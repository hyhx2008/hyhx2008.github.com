<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>H.y's Blog</title>
	<meta name="description" content="">
	<meta name="author" content="hyhx2008">

	<!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
	<!--[if lt IE 9]>
		<script src="./theme/html5.js"></script>
	<![endif]-->

	<!-- Le styles -->
	<link href="./theme/bootstrap.min.css" rel="stylesheet">
	<link href="./theme/local.css" rel="stylesheet">
	<link href="./theme/pygments.css" rel="stylesheet">
	
<script>var _gaq=[['_setAccount','UA-36075477-1'],['_trackPageview']];(function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];g.src='//www.google-analytics.com/ga.js';s.parentNode.insertBefore(g,s)}(document,'script'))</script>

	
<script type="text/javascript">
	var disqus_identifier = "peersimshi-yong-jiao-cheng-4-gou-jian-ge-tuo-bu-sheng-cheng-qi.html";
	(function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = 'http://hysblog.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	})();
</script>

		
	<link rel="shortcut icon" href="./theme/images/icons/icon1.png">
</head>
<body>
	
	
<a href="https://github.com/hyhx2008"><img style="position: absolute; top: 39px; right: 0; border: 0;" src="http://s3.amazonaws.com/github/ribbons/forkme_right_white_ffffff.png" alt="Fork me on GitHub" /></a>

	<div class="topbar">
	  <div class="topbar-inner">
		<div class="container-fluid">
		  <a class="brand" href="./index.html">H.y's Blog</a>
			<ul class="nav">
				
				
					
				
				
					<li ><a href="./category/intern.html">intern</a></li>
				
					<li ><a href="./category/my.html">my</a></li>
				
					<li class="active"><a href="./category/peersim.html">peersim</a></li>
				
					<li ><a href="./category/tech.html">tech</a></li>
				
			</ul>
			<p class="pull-right"><a href="./archives.html">[archives]</a> <a href="./tags.html">[tags]</a></p>
		</div>
	  </div>
	</div>

	<div class="container-fluid">	
	  <div class="span5 sidebar">
		<div class="well">
			<h3>Blogroll</h3>
			<ul>
				
				<li><a href="http://x-wei.github.com">x-wei</a></li>
				
				<li><a href="http://farseerfc.github.com/">farseerfc</a></li>
				
			</ul>
			<div class="social">
			<h3>Social</h3>
			<ul>
				
				<li><a href="https://github.com/hyhx2008">github</a></li>
				
			</ul>
			</div>
			
		</div>
		
		<div class="well">
			<div class="search_sidebar">
				
<li class="nav-header"><h4><i class="icon-search"></i>Google Search</h4></li>
<!-- Put the following javascript before the closing </head> tag. -->
<script>
  (function() {
    var cx = '007947589229995882978:padodsakamc';
    var gcse = document.createElement('script'); gcse.type = 'text/javascript'; gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//www.google.com/cse/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(gcse, s);
  })();
</script>
<!-- Place this tag where you want both of the search box and the search results to render -->
<gcse:search></gcse:search>

			</div>

			<div class="google_ads">
				
<li class="nav-header"><h4><i class="icon-search"></i>Google Ads</h4></li>
<script type="text/javascript"><!--
google_ad_client = "ca-pub-5617943900713834";
/* HY&#39;s github blog */
google_ad_slot = "7280262031";
google_ad_width = 160;
google_ad_height = 600;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>

			</div>
		</div>

	  </div>
	  <div class="content">
			
			
	<div class='article'>
		<div class="page-header"><h1>PeerSim使用教程(4)-构建一个拓扑生成器</h1></div>
		<div class="well small">Permalink: <a class="more" href="./peersimshi-yong-jiao-cheng-4-gou-jian-ge-tuo-bu-sheng-cheng-qi.html">2013-04-04 21:45:00</a>
by <a class="url fn" href="./author/hyhx2008.html">hyhx2008</a>
in <a href="./category/peersim.html">peersim</a>
tags: <a href="./tag/PeerSim.html">PeerSim</a> </div>
		<div><p>本文描述了在PeerSim中如何构建一个新的拓扑生成器。</p>
<p><strong>1.什么是拓扑？为什么它很重要？</strong></p>
<p>在一个大型的动态P2P系统中，节点没有关于整个网络的信息，而所有的节点都可能拥有一些邻居节点，即节点能”感知”的peers，这种”感知”的关系就定义了一个覆盖网络，这是P2P系统中的一个基本概念。</p>
<p>很多P2P协议都需要在多个不同的网络拓扑上进行实验。PeerSim中的peersim.dynamic.Wire*类已经包含了很多拓扑结构，可以直接用来对linkable协议进行初始化，本教程将展示如何构建一个自定义的拓扑生成器。</p>
<p><strong>2.一个模拟Internet的简单模型</strong></p>
<p>下面我们将编写一个拓扑生成器来构建类似于Internet的树状拓扑，整个构建过程基于一个特定的，与位置相关的preferential attachment方法，编写规则很简单，并且会考虑几何和网络的限制以更好地模拟真实的网络。
Preferential attachment由参数a来调整，这个参数能扩大或减少几何位置所带来的影响。</p>
<p>这个规则的策略如下：给定一个单位正方形，将x0置于中心，即x0 = (0.5,0.5)，这个节点被称为root，令W()为与root相隔的跳数(hops)，对于i=1 … n-1，随机在单位正方形中选择一个xi，然后选择使下面的表达式值最小的节点xj来连接它：</p>
<div class="figure">
<img alt="../statics/pics/peersim_tutorial_4_figure_1.png" src="statics/pics/peersim_tutorial_4_figure_1.png" />
</div>
<p>在这里dist()是欧几里德距离而a (alpha)是权重参数，显然，</p>
<p>W(xi) = W(xj) + 1</p>
<p>通过这个方案我们得到了一个x0以为根的树。这个拓扑中每个节点(除了root外)的出度都为1,如果想更深入地理解这个模型，可以参考下面的文章：</p>
<ul class="simple">
<li>Heuristically Optimized Trade-offs: A New Paradigm for Power Laws in the Internet</li>
<li>Degree distributions of the FKP network model</li>
<li>On Power-Law Relationships of the Internet Topology</li>
</ul>
<p><strong>3.需要编写的代码</strong></p>
<p>我们的目标是编写一个可以根据 a(alpha) 参数生成所需拓扑的PeerSim组件，并且能对生成的拓扑进行分析。
这个拓扑可以在仿真过程中逐步生成，也可以用一个步骤生成拓扑，在这里我们倾向后者。为了构建需要的拓扑结构，我们需要下面的组件(注意这只是其中一种方案)。</p>
<ul class="simple">
<li>一个protocol 类，可以存储坐标，它不具备行为元素，只是一个普通的容器</li>
<li>一个initializer 类，可以为每个节点设置坐标值</li>
<li>一个control 类， 可在一个任意的linkable协议中根据坐标连接拓扑(在节点间添加link)</li>
<li>一个observer 类，将拓扑结构打印到一个文件中(例如用GnuPlot对图进行可视化)</li>
<li>一个observer 类，用来收集节点入度的分布的统计数据</li>
<li>一个observer 类，用来测试对随机节点失效的健壮性</li>
</ul>
<p>在下节我们将看到，一些我们列出来的类是PeerSim中的基本组件，它们都实现了Linkable接口，Linkable以模块化的方式为用户提供了一个能处理任何拓扑结构的抽象。</p>
<p><strong>4.代码编写</strong></p>
<p><strong>a.Protocol类</strong></p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">peersim.core.Protocol</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">InetCoordinates</span> <span class="kd">implements</span> <span class="n">Protocol</span> <span class="o">{</span>

        <span class="cm">/** 2d coordinates components.*/</span>
        <span class="kd">private</span> <span class="kt">double</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">InetCoordinates</span><span class="o">(</span><span class="n">String</span> <span class="n">prefix</span><span class="o">)</span> <span class="o">{</span>
                <span class="cm">/* Un-initialized coordinates defaults to -1.*/</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">y</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="n">Object</span> <span class="nf">clone</span><span class="o">()</span> <span class="o">{</span>
                <span class="n">InetCoordinates</span> <span class="n">inp</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                <span class="k">try</span> <span class="o">{</span>
                        <span class="n">inp</span> <span class="o">=</span> <span class="o">(</span><span class="n">InetCoordinates</span><span class="o">)</span> <span class="kd">super</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">CloneNotSupportedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="o">}</span> <span class="c1">// never happens</span>

                <span class="k">return</span> <span class="n">inp</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">double</span> <span class="nf">getX</span><span class="o">()</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setX</span><span class="o">(</span><span class="kt">double</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">this</span><span class="o">.</span><span class="na">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">double</span> <span class="nf">getY</span><span class="o">()</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">y</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setY</span><span class="o">(</span><span class="kt">double</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">this</span><span class="o">.</span><span class="na">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
        <span class="o">}</span>
<span class="o">}</span>
</pre></div>
<p>这个类只存储坐标，而links则会存储在其它任意实现了Linkable接口的协议中。</p>
<p>clone方法必须新定义并且捕捉和压制所有的异常（它们永远不会被抛出），因为这里只有基本类型，不需要深拷贝操作。</p>
<p>坐标组件并不是public的，但可以通过getter/setter方法来存取 ，这是很重要的，因为我们可以使用peersim.vector包以一个弹性化的方式来初始化坐标值，但在本文中我们并没有使用这个包。</p>
<p><strong>b.初始化类</strong></p>
<div class="highlight"><pre><span class="kn">package</span> <span class="n">example</span><span class="o">.</span><span class="na">hot</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">peersim.config.Configuration</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">peersim.core.CommonState</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">peersim.core.Control</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">peersim.core.Network</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">peersim.core.Node</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">InetInitializer</span> <span class="kd">implements</span> <span class="n">Control</span> <span class="o">{</span>

        <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">PAR_PROT</span> <span class="o">=</span> <span class="s">&quot;protocol&quot;</span><span class="o">;</span>

        <span class="cm">/** Protocol identifier, obtained from config property*/</span>
        <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">pid</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">InetInitializer</span><span class="o">(</span><span class="n">String</span> <span class="n">prefix</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">pid</span> <span class="o">=</span> <span class="n">Configuration</span><span class="o">.</span><span class="na">getPid</span><span class="o">(</span><span class="n">prefix</span> <span class="o">+</span> <span class="s">&quot;.&quot;</span> <span class="o">+</span> <span class="n">PAR_PROT</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="cm">/**</span>
<span class="cm">        * Initialize the node coordinates. The first node in the Network</span>
<span class="cm">        * is the root node by default and it is located in the middle</span>
<span class="cm">        * (the center of the square) of the surface area.*/</span>
        <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">execute</span><span class="o">()</span> <span class="o">{</span>
                <span class="c1">// Set the root: the index 0 node by default.</span>
                <span class="n">Node</span> <span class="n">n</span> <span class="o">=</span> <span class="n">Network</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
                <span class="n">InetCoordinates</span> <span class="n">prot</span> <span class="o">=</span> <span class="o">(</span><span class="n">InetCoordinates</span><span class="o">)</span> <span class="n">n</span><span class="o">.</span><span class="na">getProtocol</span><span class="o">(</span><span class="n">pid</span><span class="o">);</span>
                <span class="n">prot</span><span class="o">.</span><span class="na">setX</span><span class="o">(</span><span class="mf">0.5</span><span class="o">);</span>
                <span class="n">prot</span><span class="o">.</span><span class="na">setY</span><span class="o">(</span><span class="mf">0.5</span><span class="o">);</span>
                <span class="c1">// Set coordinates x,y</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">Network</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                        <span class="n">n</span> <span class="o">=</span> <span class="n">Network</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
                        <span class="n">prot</span> <span class="o">=</span> <span class="o">(</span><span class="n">InetCoordinates</span><span class="o">)</span> <span class="n">n</span><span class="o">.</span><span class="na">getProtocol</span><span class="o">(</span><span class="n">pid</span><span class="o">);</span>
                        <span class="n">prot</span><span class="o">.</span><span class="na">setX</span><span class="o">(</span><span class="n">CommonState</span><span class="o">.</span><span class="na">r</span><span class="o">.</span><span class="na">nextDouble</span><span class="o">());</span>
                        <span class="n">prot</span><span class="o">.</span><span class="na">setY</span><span class="o">(</span><span class="n">CommonState</span><span class="o">.</span><span class="na">r</span><span class="o">.</span><span class="na">nextDouble</span><span class="o">());</span>
                <span class="o">}</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
<span class="o">}</span>
</pre></div>
<p>初始化类应当实现Control接口中唯一的execute方法，构造方法从配置文件中读取唯一的参数(protocol)，它声明了持有坐标的协议。</p>
<p>这个类是很简单的，它生成了一致的随机坐标(x和y),唯一的例外是root节点，默认情况下，它的下标是0，固定为(0.5,0.5)。</p>
<p>为了生成随机数，CommonState中的静态的数据域r必须总是使用，因为这样保证了实验的可重复性。</p>
<p><strong>c.Writing类</strong></p>
<p>这个类继承了peersim.dynamic.WireGraph，它实现了Control接口并提供了处理拓扑的通用功能，同时也提供了一个图的接口。
wiring的逻辑应该放在由子类调用的wire方法中，并且在默认情况下将下标为0的节点视为root。</p>
<p>这个类需要从配置文件中读取 a(配置文件中的alpha)和坐标容器的protocol ID(配置文件中的coord_protocol)，这是由类的的构造方法来完成的，其它的参数，比如 protocol 是由父类继承的，它是一个实现了Linkable接口的协议。</p>
<div class="highlight"><pre><span class="kn">package</span> <span class="n">example</span><span class="o">.</span><span class="na">hot</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">peersim.config.Configuration</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">peersim.core.Linkable</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">peersim.core.Network</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">peersim.core.Node</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">peersim.dynamics.WireGraph</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">peersim.graph.Graph</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">WireInetTopology</span> <span class="kd">extends</span> <span class="n">WireGraph</span> <span class="o">{</span>

        <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">PAR_ALPHA</span> <span class="o">=</span> <span class="s">&quot;alpha&quot;</span><span class="o">;</span>
        <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">PAR_COORDINATES_PROT</span> <span class="o">=</span> <span class="s">&quot;coord_protocol&quot;</span><span class="o">;</span>

        <span class="c1">// A parameter that affects the distance importance.</span>
        <span class="kd">private</span> <span class="kd">final</span> <span class="kt">double</span> <span class="n">alpha</span><span class="o">;</span>

        <span class="c1">// Coordinate protocol pid.</span>
        <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">coordPid</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">WireInetTopology</span><span class="o">(</span><span class="n">String</span> <span class="n">prefix</span><span class="o">)</span> <span class="o">{</span>
                <span class="kd">super</span><span class="o">(</span><span class="n">prefix</span><span class="o">);</span>
                <span class="n">alpha</span> <span class="o">=</span> <span class="n">Configuration</span><span class="o">.</span><span class="na">getDouble</span><span class="o">(</span><span class="n">prefix</span> <span class="o">+</span> <span class="s">&quot;.&quot;</span> <span class="o">+</span> <span class="n">PAR_ALPHA</span><span class="o">,</span> <span class="mf">0.5</span><span class="o">);</span>
                <span class="n">coordPid</span> <span class="o">=</span> <span class="n">Configuration</span><span class="o">.</span><span class="na">getPid</span><span class="o">(</span><span class="n">prefix</span> <span class="o">+</span> <span class="s">&quot;.&quot;</span> <span class="o">+</span> <span class="n">PAR_COORDINATES_PROT</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="cm">/**</span>
<span class="cm">        * Performs the actual wiring.</span>
<span class="cm">        * @param g</span>
<span class="cm">        * a peersim.graph.Graph interface object to work on.*/</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">wire</span><span class="o">(</span><span class="n">Graph</span> <span class="n">g</span><span class="o">)</span> <span class="o">{</span>

                <span class="c1">// Contains the distance in hops from the root node</span>
                <span class="c1">// for each node.</span>

                <span class="kt">int</span><span class="o">[]</span> <span class="n">hops</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">Network</span><span class="o">.</span><span class="na">size</span><span class="o">()];</span>

                <span class="c1">// connect all the nodes other than roots</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">Network</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">Node</span> <span class="n">n</span> <span class="o">=</span> <span class="o">(</span><span class="n">Node</span><span class="o">)</span> <span class="n">g</span><span class="o">.</span><span class="na">getNode</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
                        <span class="c1">// Look for a suitable parent node between those</span>
                        <span class="c1">// allready part of the overlay topology: alias</span>
                        <span class="c1">// FIND THE MINIMUM!</span>
                        <span class="c1">// Node candidate = null;</span>
                        <span class="kt">int</span> <span class="n">candidate_index</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                        <span class="kt">double</span> <span class="n">min</span> <span class="o">=</span> <span class="n">Double</span><span class="o">.</span><span class="na">POSITIVE_INFINITY</span><span class="o">;</span>

                        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                                <span class="n">Node</span> <span class="n">parent</span> <span class="o">=</span> <span class="o">(</span><span class="n">Node</span><span class="o">)</span> <span class="n">g</span><span class="o">.</span><span class="na">getNode</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
                                <span class="kt">double</span> <span class="n">jHopDistance</span> <span class="o">=</span> <span class="n">hops</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
                                <span class="kt">double</span> <span class="n">value</span> <span class="o">=</span> <span class="n">jHopDistance</span> <span class="o">+</span>
                                        <span class="o">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">distance</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">parent</span><span class="o">,</span> <span class="n">coordPid</span><span class="o">));</span>
                                <span class="k">if</span> <span class="o">(</span><span class="n">value</span> <span class="o">&lt;</span> <span class="n">min</span><span class="o">)</span> <span class="o">{</span>
                                <span class="c1">// candidate = parent;</span>
                                <span class="c1">// best parent node to connect to</span>
                                        <span class="n">min</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
                                        <span class="n">candidate_index</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span>
                                <span class="o">}</span>
                        <span class="o">}</span>
                        <span class="n">hops</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">hops</span><span class="o">[</span><span class="n">candidate_index</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
                        <span class="n">g</span><span class="o">.</span><span class="na">setEdge</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">candidate_index</span><span class="o">);</span>
                <span class="o">}</span>
        <span class="o">}</span>

        <span class="kd">private</span> <span class="kd">static</span> <span class="kt">double</span> <span class="nf">distance</span><span class="o">(</span><span class="n">Node</span> <span class="n">new_node</span><span class="o">,</span><span class="n">Node</span> <span class="n">old_node</span><span class="o">,</span> <span class="kt">int</span> <span class="n">coordPid</span><span class="o">)</span> <span class="o">{</span>
                <span class="kt">double</span> <span class="n">x1</span> <span class="o">=</span> <span class="o">((</span><span class="n">InetCoordinates</span><span class="o">)</span> <span class="n">new_node</span><span class="o">.</span><span class="na">getProtocol</span><span class="o">(</span><span class="n">coordPid</span><span class="o">)).</span><span class="na">getX</span><span class="o">();</span>
                <span class="kt">double</span> <span class="n">x2</span> <span class="o">=</span> <span class="o">((</span><span class="n">InetCoordinates</span><span class="o">)</span> <span class="n">old_node</span><span class="o">.</span><span class="na">getProtocol</span><span class="o">(</span><span class="n">coordPid</span><span class="o">)).</span><span class="na">getX</span><span class="o">();</span>
                <span class="kt">double</span> <span class="n">y1</span> <span class="o">=</span> <span class="o">((</span><span class="n">InetCoordinates</span><span class="o">)</span> <span class="n">new_node</span><span class="o">.</span><span class="na">getProtocol</span><span class="o">(</span><span class="n">coordPid</span><span class="o">)).</span><span class="na">getY</span><span class="o">();</span>
                <span class="kt">double</span> <span class="n">y2</span> <span class="o">=</span> <span class="o">((</span><span class="n">InetCoordinates</span><span class="o">)</span> <span class="n">old_node</span><span class="o">.</span><span class="na">getProtocol</span><span class="o">(</span><span class="n">coordPid</span><span class="o">)).</span><span class="na">getY</span><span class="o">();</span>

                <span class="k">if</span> <span class="o">(</span><span class="n">x1</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">x2</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">y1</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">y2</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span>

                <span class="c1">// NOTE: in release 1.0 the line above incorrectly</span>

                <span class="c1">// contains | -s instead of ||. Use latest CVS version,</span>

                <span class="c1">// or fix it by hand.</span>
                        <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span>
                                <span class="s">&quot;Found un-initialized coordinate. Use e.g.,\</span>
<span class="s">                                InetInitializer class in the config file.&quot;</span><span class="o">);</span>

                <span class="k">return</span> <span class="n">Math</span><span class="o">.</span><span class="na">sqrt</span><span class="o">((</span><span class="n">x1</span> <span class="o">-</span> <span class="n">x2</span><span class="o">)</span> <span class="o">*</span> <span class="o">(</span><span class="n">x1</span> <span class="o">-</span> <span class="n">x2</span><span class="o">)</span>
                                        <span class="o">+</span> <span class="o">(</span><span class="n">y1</span> <span class="o">-</span> <span class="n">y2</span><span class="o">)</span> <span class="o">*</span> <span class="o">(</span><span class="n">y1</span> <span class="o">-</span> <span class="n">y2</span><span class="o">));</span>
        <span class="o">}</span>
<span class="o">}</span>
</pre></div>
<p><strong>d.Observers</strong></p>
<p>前面提到的observer有些已经由PeerSim提供了相应的实现。例如，为了计算节点度的分布，用户可以使用peersim.reports.DegreeStats；
为了检验网络的健壮性，可以使用peersim.reports.RandRemoval：它打印生成的clusters的数目及大小，并作为随机删除的节点数量的函数。
然而，为了将拓扑转换为可绘图的形式，需要自行编写observer：
InetObserver实现了Control接口和对应的execute方法，我们继承了peersim.reports.GraphObserver，这个模板类能简化对图的观察。</p>
<p>构造方法根据配置文件进行初始化，其中参数protocol引用了Protocol ID，它拥有”who knows who”的关系（它必须是一个Linkable 协议），这是由超类继承而来。
其它的参数，coord_protocol和file_base，分别是坐标容器的协议名和将要使用的文件名前缀。
这样，最终由程序生成的文件名是：file_base + %08d + .dat，中间的8位数字是指周期数，
因为作为一个control对象，observer可以在每个周期中运行，在这种情况下每次应该生成一个不同的文件。</p>
<div class="highlight"><pre><span class="kn">package</span> <span class="n">example</span><span class="o">.</span><span class="na">hot</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.io.FileOutputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.PrintStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">peersim.config.Configuration</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">peersim.core.Node</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">peersim.graph.Graph</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">peersim.reports.GraphObserver</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">peersim.util.FileNameGenerator</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">InetObserver</span> <span class="kd">extends</span> <span class="n">GraphObserver</span> <span class="o">{</span>

        <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">PAR_FILENAME_BASE</span> <span class="o">=</span> <span class="s">&quot;file_base&quot;</span><span class="o">;</span>
        <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">PAR_COORDINATES_PROT</span>
                                        <span class="o">=</span> <span class="s">&quot;coord_protocol&quot;</span><span class="o">;</span>

        <span class="kd">private</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">graph_filename</span><span class="o">;</span>
        <span class="kd">private</span> <span class="kd">final</span> <span class="n">FileNameGenerator</span> <span class="n">fng</span><span class="o">;</span>
        <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">coordPid</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">InetObserver</span><span class="o">(</span><span class="n">String</span> <span class="n">prefix</span><span class="o">)</span> <span class="o">{</span>
                <span class="kd">super</span><span class="o">(</span><span class="n">prefix</span><span class="o">);</span>
                <span class="n">coordPid</span> <span class="o">=</span> <span class="n">Configuration</span><span class="o">.</span><span class="na">getPid</span><span class="o">(</span><span class="n">prefix</span> <span class="o">+</span> <span class="s">&quot;.&quot;</span>
                                <span class="o">+</span> <span class="n">PAR_COORDINATES_PROT</span><span class="o">);</span>
                <span class="n">graph_filename</span> <span class="o">=</span> <span class="n">Configuration</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="n">prefix</span> <span class="o">+</span> <span class="s">&quot;.&quot;</span>
                                <span class="o">+</span> <span class="n">PAR_FILENAME_BASE</span><span class="o">,</span> <span class="s">&quot;graph_dump&quot;</span><span class="o">);</span>
                <span class="n">fng</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileNameGenerator</span><span class="o">(</span><span class="n">graph_filename</span><span class="o">,</span> <span class="s">&quot;.dat&quot;</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Control interface method.</span>
        <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">execute</span><span class="o">()</span> <span class="o">{</span>
                <span class="k">try</span> <span class="o">{</span>
                        <span class="n">updateGraph</span><span class="o">();</span>
                        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">name</span> <span class="o">+</span> <span class="s">&quot;: &quot;</span><span class="o">);</span>
                        <span class="c1">// initialize output streams</span>
                        <span class="n">String</span> <span class="n">fname</span> <span class="o">=</span> <span class="n">fng</span><span class="o">.</span><span class="na">nextCounterName</span><span class="o">();</span>
                        <span class="n">FileOutputStream</span> <span class="n">fos</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileOutputStream</span><span class="o">(</span><span class="n">fname</span><span class="o">);</span>
                        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Writing to file &quot;</span> <span class="o">+</span> <span class="n">fname</span><span class="o">);</span>
                        <span class="n">PrintStream</span> <span class="n">pstr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PrintStream</span><span class="o">(</span><span class="n">fos</span><span class="o">);</span>
                        <span class="c1">// dump topology:</span>
                        <span class="n">graphToFile</span><span class="o">(</span><span class="n">g</span><span class="o">,</span> <span class="n">pstr</span><span class="o">,</span> <span class="n">coordPid</span><span class="o">);</span>
                        <span class="n">fos</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                        <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">graphToFile</span><span class="o">(</span><span class="n">Graph</span> <span class="n">g</span><span class="o">,</span> <span class="n">PrintStream</span> <span class="n">ps</span><span class="o">,</span><span class="kt">int</span> <span class="n">coordPid</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">g</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                        <span class="n">Node</span> <span class="n">current</span> <span class="o">=</span> <span class="o">(</span><span class="n">Node</span><span class="o">)</span> <span class="n">g</span><span class="o">.</span><span class="na">getNode</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
                        <span class="kt">double</span> <span class="n">x_to</span> <span class="o">=</span> <span class="o">((</span><span class="n">InetCoordinates</span><span class="o">)</span>
                                <span class="n">current</span><span class="o">.</span><span class="na">getProtocol</span><span class="o">(</span><span class="n">coordPid</span><span class="o">)).</span><span class="na">getX</span><span class="o">();</span>
                        <span class="kt">double</span> <span class="n">y_to</span> <span class="o">=</span> <span class="o">((</span><span class="n">InetCoordinates</span><span class="o">)</span>
                                <span class="n">current</span><span class="o">.</span><span class="na">getProtocol</span><span class="o">(</span><span class="n">coordPid</span><span class="o">)).</span><span class="na">getY</span><span class="o">();</span>

                        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">index</span> <span class="o">:</span> <span class="n">g</span><span class="o">.</span><span class="na">getNeighbours</span><span class="o">(</span><span class="n">i</span><span class="o">))</span> <span class="o">{</span>
                                <span class="n">Node</span> <span class="n">n</span> <span class="o">=</span> <span class="o">(</span><span class="n">Node</span><span class="o">)</span> <span class="n">g</span><span class="o">.</span><span class="na">getNode</span><span class="o">(</span><span class="n">index</span><span class="o">);</span>
                                <span class="kt">double</span> <span class="n">x_from</span> <span class="o">=</span> <span class="o">((</span><span class="n">InetCoordinates</span><span class="o">)</span>
                                        <span class="n">n</span><span class="o">.</span><span class="na">getProtocol</span><span class="o">(</span><span class="n">coordPid</span><span class="o">)).</span><span class="na">getX</span><span class="o">();</span>
                                <span class="kt">double</span> <span class="n">y_from</span> <span class="o">=</span> <span class="o">((</span><span class="n">InetCoordinates</span><span class="o">)</span>
                                        <span class="n">n</span><span class="o">.</span><span class="na">getProtocol</span><span class="o">(</span><span class="n">coordPid</span><span class="o">)).</span><span class="na">getY</span><span class="o">();</span>
                                <span class="n">ps</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">x_from</span> <span class="o">+</span> <span class="s">&quot; &quot;</span> <span class="o">+</span> <span class="n">y_from</span><span class="o">);</span>
                                <span class="n">ps</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">x_to</span> <span class="o">+</span> <span class="s">&quot; &quot;</span> <span class="o">+</span> <span class="n">y_to</span><span class="o">);</span>
                                <span class="n">ps</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
                        <span class="o">}</span>
                <span class="o">}</span>
        <span class="o">}</span>
<span class="o">}</span>
</pre></div>
<p>在execute方法中我们必须调用 updateGraph方法(a GraphObserver protected method)以检验实际的图中是否发生了变化，
这是为了在很多observer运行于同一个图中的时候节省构造图的时间。如果许多observers观察同一个图的无向版本，那节省时间的时间是很显著的。
注意在execute方法中使用的IO库函数可能抛出一些异常，这里任意的异常都被捕获并重新作为运行时异常抛出，它们会导致仿真的终止。</p>
<p>静态的功能方法graphToFile将实际的拓扑结构写到磁盘中，对于每个节点n，收集其x和y坐标，而对于节点n的每个邻居节点i，其坐标将会是下面的格式：</p>
<p>1&gt; n.neighbor(i).x n.neighbor(i).y newline</p>
<p>2&gt; n.x n.y newline</p>
<p>3&gt; newline}</p>
<p>这种格式很适合于用GnuPlot来绘图，请注意循环是从下标1而不是0开始的，这是因为节点0是root,它没有向外的连接。</p>
<p><strong>5.运行实验</strong></p>
<p>下面是本实验所对应的配置文件：</p>
<div class="highlight"><pre><span class="cp"># Complex Network file:</span>
<span class="cp"># random.seed 1234567890</span>
<span class="n">simulation</span><span class="p">.</span><span class="n">cycles</span> <span class="mi">1</span>
<span class="n">network</span><span class="p">.</span><span class="n">size</span> <span class="mi">10000</span>
<span class="n">protocol</span><span class="p">.</span><span class="n">link</span> <span class="n">IdleProtocol</span>
<span class="n">protocol</span><span class="p">.</span><span class="n">coord</span> <span class="n">example</span><span class="p">.</span><span class="n">hot</span><span class="p">.</span><span class="n">InetCoordinates</span>
<span class="n">init</span><span class="mf">.0</span> <span class="n">example</span><span class="p">.</span><span class="n">hot</span><span class="p">.</span><span class="n">InetInitializer</span>
<span class="n">init</span><span class="mf">.0</span><span class="p">.</span><span class="n">protocol</span> <span class="n">coord</span>
<span class="n">init</span><span class="mf">.1</span> <span class="n">example</span><span class="p">.</span><span class="n">hot</span><span class="p">.</span><span class="n">WireInetTopology</span>
<span class="n">init</span><span class="mf">.1</span><span class="p">.</span><span class="n">protocol</span> <span class="n">link</span> <span class="err">#</span><span class="n">the</span> <span class="n">linkable</span> <span class="n">to</span> <span class="n">be</span> <span class="n">wired</span>
<span class="n">init</span><span class="mf">.1</span><span class="p">.</span><span class="n">coord_protocol</span> <span class="n">coord</span>
<span class="n">init</span><span class="mf">.1</span><span class="p">.</span><span class="n">alpha</span> <span class="mi">4</span>
<span class="n">control</span><span class="p">.</span><span class="n">io</span> <span class="n">example</span><span class="p">.</span><span class="n">hot</span><span class="p">.</span><span class="n">InetObserver</span>
<span class="n">control</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">protocol</span> <span class="n">link</span>
<span class="n">control</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">coord_protocol</span> <span class="n">coord</span>
<span class="n">control</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">file_base</span> <span class="n">graph</span>
<span class="n">control</span><span class="p">.</span><span class="n">degree</span> <span class="n">DegreeStats</span>
<span class="n">control</span><span class="p">.</span><span class="n">degree</span><span class="p">.</span><span class="n">protocol</span> <span class="n">link</span>
<span class="n">control</span><span class="p">.</span><span class="n">degree</span><span class="p">.</span><span class="n">undir</span>
<span class="n">control</span><span class="p">.</span><span class="n">degree</span><span class="p">.</span><span class="n">method</span> <span class="n">freq</span>
<span class="n">include</span><span class="p">.</span><span class="n">control</span> <span class="n">io</span> <span class="n">degree</span>
</pre></div>
<div class="figure">
<img alt="../statics/pics/peersim_tutorial_4_figure_2.png" src="statics/pics/peersim_tutorial_4_figure_2.png" />
</div>
<p>Figure 1: Topology and in-degree distribution with a 4</p>
<div class="figure">
<img alt="../statics/pics/peersim_tutorial_4_figure_3.png" src="statics/pics/peersim_tutorial_4_figure_3.png" />
</div>
<p>Figure 2: Topology and in-degree distribution with a 20</p>
<div class="figure">
<img alt="../statics/pics/peersim_tutorial_4_figure_4.png" src="statics/pics/peersim_tutorial_4_figure_4.png" />
</div>
<p>Figure 3: Topology and in-degree distribution with a 100</p>
<p>它根据init.0部分的参数生成了具有10000个节点的覆盖网络。下面的图展示了在a不同的情况下生成的拓扑。
事实上，它影响了系统的聚类行为并且它与网络的大小紧密相关:
如果，拓扑将变得越来越聚集，在a很小时，则拓扑会变成星形结构。 如果，拓扑将趋向于随机分布而不是聚集在一起。</p>
<p>DegreeStats可以用来收集节点度的统计信息，然而，应当慎重地使用它。
因为在PeerSim的默认情况下，“度”是指“出度”，然而我们感兴趣的是“入度”，那怎么样才能观察入度呢？
首先我们将图视为无向图（通过undir参数）,然后我们进行频率统计（freq参数）来绘图，observer会输出类似于下面的数据：</p>
<div class="highlight"><pre><span class="go">1 9838</span>
<span class="go">2 38</span>
<span class="go">3 19</span>
<span class="go">4 14</span>
<span class="go">5 7</span>
<span class="go">6 7</span>
<span class="go">7 7</span>
<span class="go">8 4</span>
<span class="go">9 3</span>
<span class="go">10 3</span>
<span class="go">11 1</span>
<span class="go">12 5</span>
<span class="go">...</span>
<span class="go">...</span>
<span class="go">543 1</span>
<span class="go">566 1</span>
<span class="go">620 1</span>
<span class="go">653 1</span>
<span class="go">2153 1</span>
</pre></div>
<p>第一列对应于度数，而第二列是指拥有相应度数的节点数量，我们可以肯定除了root以外，其它每个节点都只有一个out-link，同时所有的link都是严格单向的，因而为了取得入度我们只需要从第一列简单地减去1即可。</p>
</div>
		<div>
			<h2>Comments</h2>
		 	
			<div id="disqus_thread"></div>
			
		<div>
	</div>	

		<footer>
		  <p> Powered by <a href="http://alexis.notmyidea.org/pelican/">Pelican</a>, theme based on <a href="http://twitter.github.com/bootstrap/">Bootstrap, from Twitter</a>.</p>
		  <p>&copy; hyhx2008 2011</p>
		</footer>
	  </div>
   
	</div>
</body>
</html>