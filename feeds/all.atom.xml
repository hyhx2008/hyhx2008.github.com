<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>H.y's Blog</title><link href="http://hyhx2008.github.com/" rel="alternate"></link><link href="http://hyhx2008.github.com/feeds/all.atom.xml" rel="self"></link><id>http://hyhx2008.github.com/</id><updated>2013-03-21T20:10:00+09:00</updated><entry><title>PeerSim使用教程(2)-解析Cycle-based模式仿真</title><link href="http://hyhx2008.github.com/peersimshi-yong-jiao-cheng-2-jie-xi-cycle-basedmo-shi-fang-zhen.html" rel="alternate"></link><updated>2013-03-21T20:10:00+09:00</updated><author><name>hyhx2008</name></author><id>tag:hyhx2008.github.com,2013-03-21:peersimshi-yong-jiao-cheng-2-jie-xi-cycle-basedmo-shi-fang-zhen.html</id><summary type="html">&lt;p&gt;PeerSim提供的文档并不多，一共三篇，可以在其官网上下载，这里给一个链接:
&lt;a class="reference external" href="http://peersim.sourceforge.net/#docs"&gt;PeerSim: Documentation&lt;/a&gt;
，是学习PeerSim必看资料。&lt;/p&gt;
&lt;p&gt;英文有时不是很好理解，网上有个哥们将其翻译成中文了，不过他的网页最近好像失效了，这里和后面的教程基本上是整理了一下他的翻译，同时也感谢那位哥们的工作。&lt;/p&gt;
&lt;p&gt;本文介绍了PeerSim的基本概念，并解析了两个示例以更清晰地说明PeeSim的仿真流程。&lt;/p&gt;
&lt;p&gt;Peersim支持两种仿真模式，即Cycle-based模型和传统的Event-based模型，本文专注于前者的讲解。&lt;/p&gt;
&lt;p&gt;Cycle-based模型是一个简化的模型，拥有更好的伸缩性及性能，在拥有4GB内存的情况下，Event-driven模式目前最多支持十万节点级别，而Cycle-based模式则支持千万个节点级别。 但是Cycle-based模型缺少对传输层的仿真和并行处理，节点之间是直接通信的，仿真核心以一定的顺序周期性地给以节点控制。在运行时，可以进行任意的操作，如调用其它对象的方法并执行一些计算。&lt;/p&gt;
&lt;p&gt;Cycle-based模型损失了一些真实性，虽然一些简单的协议可以忽略这些差别，但是在选择使用这个模型时，需要注意这些区别。我们可以相对简单地将Cycle-based的仿真移植到Event-driven引擎上，但在本文中不讨论这个话题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.PeerSim仿真的生命周期&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;PeerSim鼓励基于接口的模块化编程，每一个组件都能被其它实现了相同接口的组件代替，一般的仿真过程如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1&amp;gt; 选择网络大小(即节点数量)。&lt;/p&gt;
&lt;p&gt;2&amp;gt; 选择要实验的一个或多协议并进行初始化。&lt;/p&gt;
&lt;p&gt;3&amp;gt; 选择一个或多个Control对象来监视感兴趣的属性，并在仿真时修改一些参数(比如，网络大小，协议的内部状态，等等)。&lt;/p&gt;
&lt;p&gt;4&amp;gt; 根据配置文件，调用Simulator类运行仿真。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在仿真时创建的对象都是实现了一个或多个接口的类的实例，主要的接口如下表所示：&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="../statics/pics/peersim_tutorial_2_table_1.png" src="../statics/pics/peersim_tutorial_2_table_1.png" /&gt;
&lt;/div&gt;
&lt;p&gt;Cycle-based仿真的生命周期是这样的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1&amp;gt; 读取配置文件（通过命令行参数传递进来），然后仿真器初始化网络中的节点和节点中的协议，每个节点都拥有相同的协议栈。节点和协议的实例是通过克隆来创建的，只有一个原型是通过构造方法创建，其它的节点和协议都是从这个原型中克隆而来。基于这个原因，协议类中clone方法的实现是很重要的。&lt;/p&gt;
&lt;p&gt;2&amp;gt; 初始化操作，设置每个协议的初始状态。初始化阶段是由一个或多个Control对象控制运行的，仅在实验开始时运行一次。在配置文件中，初始化的组件可以由init前缀识别，在下面讨论的initializer对象也是Controls，但为了标记其功能以区别于一般的Control对象，它被配置用来在初始阶段运行。&lt;/p&gt;
&lt;p&gt;3&amp;gt; 在初始化完成后，Cycle-based引擎在每一个周期中调用所有组件（Protocols和Controls）一次，直到完成了指定的周期数，或者某个组件决定终止仿真为止。在PeerSim中每一个对象（Controls和Protocols）都被赋以一个Scheduler对象，它定义了什么时候本组件将会被执行。在默认情况下，所有对象都会在每个周期中运行。但我们也可以配置一个Protocol或Control只在某些特定的周期中运行，也可以在每一个周期中指定组件的执行顺序。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下图展示了对controls和protocols的调度，其中C代表Control而P代表一个Protocol。图下方的数字代表PeerSim的周期，在最后一个周期后，可以运行一个Control来获取最后的快照(snapshot)。&lt;/p&gt;
&lt;p&gt;下图展示了对controls和protocols的调度，其中C代表Control而P代表一个Protocol。图下方的数字代表PeerSim的周期，在最后一个周期后，可以运行一个Control来获取最后的快照(snapshot)。&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="../statics/pics/peersim_tutorial_2_figure_1.png" src="../statics/pics/peersim_tutorial_2_figure_1.png" /&gt;
&lt;/div&gt;
&lt;p&gt;在一个Control收集数据时，数据将会被格式化并发送到标准输出或重定向到一个文件以进行后续的处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.配置文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;配置文件只是一个普通的ASCII文本，本质上就是一组由key-value对组成的java.util.Properties，以#开头的行代表注释。&lt;/p&gt;
&lt;p&gt;若要在命令行模式下进行仿真，可以用下面的命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="go"&gt;java -cp  peersim.Simulator config-edexample.txt&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;-cp后面需要注明classpath，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="go"&gt;java -cp D:\library\peersim-1.0.5\jep-2.3.0.jar;D:\library\peersim-1.0.5\djep-1.0.0.jar;D:\library\peersim-1.0.5\peersim-1.0.5.jar;D:\library\peersim-1.0.5\peersim-doclet.jar peersim.Simulator D:\library\peersim-1.0.5\example\config-edexample.txt&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2.1 配置文件example 1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本例将创建一个由50000个节点组成的固定P2P随机拓扑，选定的协议是使用average函数的Aggregation协议，每个节点中用于求平均的值使用一个区间在(0,100)的线性分布来初始化，最后再定义一个Control监视平均值。&lt;/p&gt;
&lt;p&gt;注：Aggregation是聚集的意思，这里是指对一个分布于网络中的数值集合运行一个特定的函数进行计算（如求平均数，最大值，最小值等等）。在Gossip-based Aggregation协议中，每个节点周期性地选择一个邻居节点进行通讯（基于覆盖网），并且在每次通讯时，基于前一个取得的近似值，相互更新它们下次计算的近似值。&lt;/p&gt;
&lt;p&gt;example1就放在config-example1.txt中：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;# PEERSIM EXAMPLE 1&lt;/span&gt;

&lt;span class="n"&gt;random&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;seed&lt;/span&gt; &lt;span class="mi"&gt;1234567890&lt;/span&gt;
&lt;span class="n"&gt;simulation&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cycles&lt;/span&gt; &lt;span class="mi"&gt;30&lt;/span&gt;

&lt;span class="n"&gt;control&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;shf&lt;/span&gt; &lt;span class="n"&gt;Shuffle&lt;/span&gt;

&lt;span class="n"&gt;network&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="mi"&gt;50000&lt;/span&gt;

&lt;span class="n"&gt;protocol&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lnk&lt;/span&gt; &lt;span class="n"&gt;IdleProtocol&lt;/span&gt;

&lt;span class="n"&gt;protocol&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;avg&lt;/span&gt; &lt;span class="n"&gt;example&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;aggregation&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AverageFunction&lt;/span&gt;
&lt;span class="n"&gt;protocol&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;avg&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;linkable&lt;/span&gt; &lt;span class="n"&gt;lnk&lt;/span&gt;

&lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rnd&lt;/span&gt; &lt;span class="n"&gt;WireKOut&lt;/span&gt;
&lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rnd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;protocol&lt;/span&gt; &lt;span class="n"&gt;lnk&lt;/span&gt;
&lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rnd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;

&lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;peak&lt;/span&gt; &lt;span class="n"&gt;example&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;aggregation&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PeakDistributionInitializer&lt;/span&gt;
&lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;peak&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="mi"&gt;10000&lt;/span&gt;
&lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;peak&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;protocol&lt;/span&gt; &lt;span class="n"&gt;avg&lt;/span&gt;

&lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lin&lt;/span&gt; &lt;span class="n"&gt;LinearDistribution&lt;/span&gt;
&lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lin&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;protocol&lt;/span&gt; &lt;span class="n"&gt;avg&lt;/span&gt;
&lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lin&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;max&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;
&lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lin&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;min&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;

&lt;span class="cp"&gt;# you can change this to select the peak initializer instead&lt;/span&gt;
&lt;span class="n"&gt;include&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;init&lt;/span&gt; &lt;span class="n"&gt;rnd&lt;/span&gt; &lt;span class="n"&gt;lin&lt;/span&gt;

&lt;span class="n"&gt;control&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;avgo&lt;/span&gt; &lt;span class="n"&gt;example&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;aggregation&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AverageObserver&lt;/span&gt;
&lt;span class="n"&gt;control&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;avgo&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;protocol&lt;/span&gt; &lt;span class="n"&gt;avg&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;p&gt;上面的配置中，一部份是全局属性，另一部分对应单个组件的实例。如simulation.cycles是全局属性，而protocol.lnk.xxx则定义了lnk协议的xxx参数。&lt;/p&gt;
&lt;p&gt;第6行的control.shf Shuffle，Shuffle类是用来重新洗牌，在每次重新洗牌后，在一个Cycle-based类型的仿真周期中，节点迭代的次序将会变成随机的，这个类只对Cycle-based类型的仿真起作用。&lt;/p&gt;
&lt;p&gt;每个组件都有一个名字，比如lnk。对于协议，这个名字将会被映射到一个在PeerSim引擎中称为protocol ID的数值型索引，虽然这个索引不出现在配置文件中，但在仿真时需要使用它来访问协议，这在后面将进一步解释。&lt;/p&gt;
&lt;p&gt;一个组件，即protocol或control由下面的语法来声明：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;protocol|init|control&amp;gt;.string_id [full_path_]classname&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;注意到类的全路径是可选的，事实上PeerSim可以在类路径中搜索类名，只有在多个类拥有相同的名称时必须使用全路径。init前缀定义了一个Initializer对象，它实现了Control接口。&lt;/p&gt;
&lt;p&gt;组件的参数（如果有的话）则以下面的语法定义：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;protocol|init|control&amp;gt;.string_id.parameter_name&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如，第10行定义了第一个协议，键部份包含了它的类型，而值则是组件的类名，由于IdleProtocol类在peersim包中，所以不必使用全路径。&lt;/p&gt;
&lt;p&gt;可以为每一个组件声明参数，如第13行；而从第3行到第8行一些全局的仿真属性被引入，如仿真的总周期数和覆盖网的大小。Shuffle control对每一个周期中节点的访问顺序进行重新洗牌。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;从第10行到第13行，引入了两个协议:&lt;/em&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1&amp;gt; IdleProtocol是存储邻居节点链路的一个静态容器，在进行静态拓扑建模的时候尤其有用，这个协议的唯一功能是作为其它协议的邻居信息的源，它没有实现CDProtocol接口但实现了Linkable接口，Linkable接口提供了到邻居节点的链路。&lt;/p&gt;
&lt;p&gt;2&amp;gt; AverageFunction是聚集协议的求平均数版本。它的参数（linkable）是很重要的，aggregation协议需要与邻居节点交流但是本身没有邻居节点列表。在模块化的方式中，它能应用于任何覆盖网络 ；定义覆盖网的协议栈应当在这里指定，参数linkable的值是实现了Linkable接口的协议的类名（在这里是IdleProtocol）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从15行到26行用于初始化之前声明的所有组件。前面声明了3个初始化组件，但只有其中的2个被使用了(见29行)。第一个初始化器，peersim.init.WireKOut，进行的是对静态覆盖网的布线，特别的，节点以度数k随机地与其它节点相连接。&lt;/p&gt;
&lt;p&gt;第2个和第3个初始化器是初始化aggregation协议的可选方案，在这里是指需要求平均的初值。初始化器设置初始值遵循peak分布或线性分布。Peak的意思是只有一个节点拥有与0不同的值。而线性则代表节点被拥有一个线性增加的值。两个初始化都需要一个指定了协议来进行初始化（协议参数）的协议名。额外的参数是PeakDistributionInitializer的range(max,min参数)。&lt;/p&gt;
&lt;p&gt;使用peak还是linear分布是由include.init属性来决定的(29行)，它指定了选择哪个初始化器。这个属性也定义了组件运行的顺序，注意到默认的顺序(即如果没有include属性)，是根据字母排序的，对于protocol和control的include属性也是如此。&lt;/p&gt;
&lt;p&gt;最后，31行和32行声明了最后一个组件：aggregation.AverageObserver。它使用的唯一参数是protocol，它引用了aggregation.AverageFunction协议类型，所以这个参数的值是avg。&lt;/p&gt;
&lt;p&gt;注释掉第3行的seed，运行这个仿真，得到的结果将是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="go"&gt;control.avgo: 0 1.0 100.0 50000 50.49999999999998 816.7990066335468 1 1&lt;/span&gt;
&lt;span class="go"&gt;control.avgo: 1 1.2970059401188023 99.38519770395408 50000 50.50000000000005 249.40673287686545 1 1&lt;/span&gt;
&lt;span class="go"&gt;control.avgo: 2 9.573571471429428 84.38874902498048 50000 50.500000000000085 77.89385877895182 1 1&lt;/span&gt;
&lt;span class="go"&gt;control.avgo: 3 23.860361582231647 71.93627224106982 50000 50.49999999999967 24.131366707228402 1 1&lt;/span&gt;
&lt;span class="go"&gt;control.avgo: 4 34.920915967147465 68.92828482118958 50000 50.49999999999994 7.702082905414273 1 1&lt;/span&gt;
&lt;span class="go"&gt;control.avgo: 5 42.37228198409946 59.94511004870823 50000 50.49999999999987 2.431356211088775 1 1&lt;/span&gt;
&lt;span class="go"&gt;control.avgo: 6 45.19621912151794 54.855516163070746 50000 50.499999999999844 0.7741451706754877 1 1&lt;/span&gt;
&lt;span class="go"&gt;control.avgo: 7 47.68716274528092 53.11433934745646 50000 50.49999999999949 0.24515365729069857 1 1&lt;/span&gt;
&lt;span class="go"&gt;control.avgo: 8 48.97706271318158 52.38916238021276 50000 50.50000000000026 0.07746523384731269 1 1&lt;/span&gt;
&lt;span class="go"&gt;control.avgo: 9 49.59674440194668 51.46963472637451 50000 50.49999999999937 0.024689348817011823 1 1&lt;/span&gt;
&lt;span class="go"&gt;control.avgo: 10 49.946490417215266 51.13343750384934 50000 50.50000000000048 0.007807022577928414 2 1&lt;/span&gt;
&lt;span class="go"&gt;control.avgo: 11 50.18143472395333 50.858337267869565 50000 50.49999999999982 0.002493501256296898 2 1&lt;/span&gt;
&lt;span class="go"&gt;control.avgo: 12 50.30454978101492 50.67203454827276 50000 50.500000000000206 7.90551008686205E-4 1 1&lt;/span&gt;
&lt;span class="go"&gt;control.avgo: 13 50.3981394834783 50.60093898689035 50000 50.49999999999967 2.518940347803474E-4 1 1&lt;/span&gt;
&lt;span class="go"&gt;control.avgo: 14 50.449347314832124 50.54962989951735 50000 50.5000000000003 8.071623184942779E-5 1 1&lt;/span&gt;
&lt;span class="go"&gt;control.avgo: 15 50.47368195506415 50.52608817343459 50000 50.49999999999999 2.566284350168338E-5 1 1&lt;/span&gt;
&lt;span class="go"&gt;control.avgo: 16 50.48510475374435 50.518871021756894 50000 50.50000000000012 8.191527862075119E-6 1 1&lt;/span&gt;
&lt;span class="go"&gt;control.avgo: 17 50.49082426764112 50.51000681641142 50000 50.49999999999945 2.570199757692886E-6 1 1&lt;/span&gt;
&lt;span class="go"&gt;control.avgo: 18 50.494810505765045 50.50556221303088 50000 50.5000000000003 8.197012224814065E-7 1 1&lt;/span&gt;
&lt;span class="go"&gt;control.avgo: 19 50.496876367842034 50.50296444951085 50000 50.499999999999524 2.640584231868471E-7 1 1&lt;/span&gt;
&lt;span class="go"&gt;control.avgo: 20 50.498457906558905 50.50182062146254 50000 50.500000000000334 8.565428611988968E-8 1 1&lt;/span&gt;
&lt;span class="go"&gt;control.avgo: 21 50.49905541635283 50.50096466374638 50000 50.49999999999974 2.721171621666857E-8 1 1&lt;/span&gt;
&lt;span class="go"&gt;control.avgo: 22 50.49946061473347 50.500553628252945 50000 50.49999999999975 8.590349265230611E-9 1 1&lt;/span&gt;
&lt;span class="go"&gt;control.avgo: 23 50.49972602272376 50.500315571370415 50000 50.5000000000004 2.6248542064007986E-9 2 1&lt;/span&gt;
&lt;span class="go"&gt;control.avgo: 24 50.4998450606816 50.50018053311878 50000 50.50000000000005 8.845012874999227E-10 1 1&lt;/span&gt;
&lt;span class="go"&gt;control.avgo: 25 50.499894793874255 50.500096923965216 50000 50.50000000000079 1.864501428663076E-10 1 2&lt;/span&gt;
&lt;span class="go"&gt;control.avgo: 26 50.4999267984512 50.500056126785694 50000 50.5000000000003 8.594896829690765E-11 1 1&lt;/span&gt;
&lt;span class="go"&gt;control.avgo: 27 50.49996613170552 50.50003198608762 50000 50.50000000000017 1.9554527178661528E-11 1 1&lt;/span&gt;
&lt;span class="go"&gt;control.avgo: 28 50.49997903068333 50.500019172164286 50000 50.499999999999766 3.274246411310768E-11 1 1&lt;/span&gt;
&lt;span class="go"&gt;control.avgo: 29 50.49998958653935 50.5000099409645 50000 50.50000000000045 0.0 1 1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Observer组件产生了很多数字，从第3列和第4列的数据（网络中的最大值和最小值），可以很容易地看到方差衰减得非常快，从第12个周期开始，几乎所有的节点都近似于真实的平均值50。可以用不同的数字或改变初始的分布（例如，使用aggregation.PeakDistributionInitializer）。同时，也可以替换覆盖网，比如你可以用Newscast来代替IdleProtocol。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.2 配置文件example 2&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第二个例子是前面例子的改进版本。现在Aggregation协议将运行于Newscast拓扑上并添加了一些扩展，例如，有一个Control对象用来改变网络的大小：在第5个周期至第10个周期间，每次调用时删除500个节点。&lt;/p&gt;
&lt;p&gt;example2就放在config-example2.txt中：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="cp"&gt;# PEERSIM EXAMPLE 2&lt;/span&gt;

    &lt;span class="n"&gt;random&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;seed&lt;/span&gt; &lt;span class="mi"&gt;1234567890&lt;/span&gt;

    &lt;span class="n"&gt;simulation&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cycles&lt;/span&gt; &lt;span class="mi"&gt;30&lt;/span&gt;

    &lt;span class="n"&gt;control&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;shf&lt;/span&gt; &lt;span class="n"&gt;Shuffle&lt;/span&gt;

    &lt;span class="n"&gt;network&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="mi"&gt;50000&lt;/span&gt;

    &lt;span class="n"&gt;protocol&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lnk&lt;/span&gt; &lt;span class="n"&gt;example&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;newscast&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SimpleNewscast&lt;/span&gt;
    &lt;span class="n"&gt;protocol&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lnk&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cache&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;

    &lt;span class="n"&gt;protocol&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;avg&lt;/span&gt; &lt;span class="n"&gt;example&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;aggregation&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AverageFunction&lt;/span&gt;
    &lt;span class="n"&gt;protocol&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;avg&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;linkable&lt;/span&gt; &lt;span class="n"&gt;lnk&lt;/span&gt;

    &lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rnd&lt;/span&gt; &lt;span class="n"&gt;WireKOut&lt;/span&gt;
    &lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rnd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;protocol&lt;/span&gt; &lt;span class="n"&gt;lnk&lt;/span&gt;
    &lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rnd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;

    &lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pk&lt;/span&gt; &lt;span class="n"&gt;example&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;aggregation&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PeakDistributionInitializer&lt;/span&gt;
    &lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pk&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="mi"&gt;10000&lt;/span&gt;
    &lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pk&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;protocol&lt;/span&gt; &lt;span class="n"&gt;avg&lt;/span&gt;

    &lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ld&lt;/span&gt; &lt;span class="n"&gt;LinearDistribution&lt;/span&gt;
    &lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ld&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;protocol&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ld&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;max&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;
    &lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ld&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;min&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;

    &lt;span class="cp"&gt;# you can change this to include the linear initializer instead&lt;/span&gt;
    &lt;span class="n"&gt;include&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;init&lt;/span&gt; &lt;span class="n"&gt;rnd&lt;/span&gt; &lt;span class="n"&gt;pk&lt;/span&gt;

    &lt;span class="n"&gt;control&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ao&lt;/span&gt; &lt;span class="n"&gt;example&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;aggregation&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AverageObserver&lt;/span&gt;
    &lt;span class="n"&gt;control&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ao&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;protocol&lt;/span&gt; &lt;span class="n"&gt;avg&lt;/span&gt;

    &lt;span class="n"&gt;control&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dnet&lt;/span&gt; &lt;span class="n"&gt;DynamicNetwork&lt;/span&gt;
    &lt;span class="n"&gt;control&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dnet&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;500&lt;/span&gt;
    &lt;span class="cp"&gt;#control.dnet.minsize 4000&lt;/span&gt;
    &lt;span class="n"&gt;control&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dnet&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;from&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;
    &lt;span class="n"&gt;control&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dnet&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;until&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;p&gt;在这里，全局参数与前面的例子相同，现在只讨论添加的扩展。&lt;/p&gt;
&lt;p&gt;11行到12行选择了Newscast协议，它唯一的参数是缓存的大小。Newscast是一个流行性的内容分布和拓扑管理协议，系统中的每个peer都有一个部份的节点信息(事实上是一个固定大小的的节点描述符(node descriptor)的集合)，每个描述符是由peer地址和一个创建描述符的时间戳组成的元组。
每个节点通过选择一个随机的邻居并交换信息来更新自身的状态，在交换信息时，两个peer归并信息并且只留下最新的项。在这种方式中，陈旧的信息（描述符）从系统中删除。这个过程允许协议修复覆盖网拓扑，用最小的代价删除死链，这种特性在一个节点频繁加入退出的动态系统中是很有用的。&lt;/p&gt;
&lt;p&gt;17到28行是初始化部分，与前面的例子相同，然而这里选择使用peak分布。为了将其转换为线性分布，在31行改变include init的属性。peak分布将用0初始化所有节点的值，除了取得value参数的那个节点除外。&lt;/p&gt;
&lt;p&gt;在36到40行，DynamicNetwork是定义的最后一个组件，如前所述，一个Control对象可以用来修改仿真中的一些参数，这种改变可以在每个仿真周期中进行（默认的行为），或者使用一种更好的途径。示例中选择的对象每次在control执行时删除500个节点。&lt;/p&gt;
&lt;p&gt;参数add指定了要添加的节点的数量，它可以是负值。而参数size则为网络大小设定了一个下限值，如果达到了下限，那不会再删除节点；参数from和until是一个可以为每个组件指定的一般化参数，它们指定了组件所要执行的周期，还有一个未使用的参数是step，如果是2，则表示每两个周期才执行一次。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.3 高级配置特性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;高级配置特性由Java Expression Parser提供，用于处理一些表达式。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;MAG 2
SIZE 2^MAG

A B+C
B D+E
C E+F
D 1
E F
F 2

# 等价于 A=7, B=3, C=4, D=1, E=2 and F=2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是注意不允许递归定义。&lt;/p&gt;
&lt;p&gt;对于组件的集合，可以指定执行的顺序，默认是根据组件名的字母顺序来排序的，但也可以显式地覆写为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;control.conn ConnectivityObserver
control.myClass Class1
control.1 Class2
order.observer myClass conn 1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果不是所有的名字都出现在这个列表中，那些缺失的对象会按字母顺序执行，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;order&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;observer&lt;/span&gt; &lt;span class="n"&gt;myClass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;会导致下面的运行顺序：observer.myClass, observer.1, observer.conn。&lt;/p&gt;
&lt;p&gt;另外一个特性是告知仿真器哪些项是允许执行的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;include&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;control&lt;/span&gt; &lt;span class="n"&gt;conn&lt;/span&gt; &lt;span class="n"&gt;myClass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样可以让control.conn和control.myClass以这种顺序执行，但如果这个列表为空，则什么都不会执行。&lt;/p&gt;
</summary><category term="PeerSim"></category><category term="Cycle-based"></category></entry><entry><title>PeerSim使用教程(1)-入门</title><link href="http://hyhx2008.github.com/peersimshi-yong-jiao-cheng-1-ru-men.html" rel="alternate"></link><updated>2013-03-20T13:40:00+09:00</updated><author><name>hyhx2008</name></author><id>tag:hyhx2008.github.com,2013-03-20:peersimshi-yong-jiao-cheng-1-ru-men.html</id><summary type="html">&lt;p&gt;最近一年所谓的研究几乎没有什么大的收获，研究的题目也一直局限在P2P，除了水文一篇，最大的收获就是学会使用PeerSim这个P2P模拟器。在这里总结一下PeerSim的使用方法，以此来结束对P2P的研究。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.PeerSim简介&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;PeerSim是一个用java编写的P2P overlay Network的模拟器，可以模拟结构化和非结构化的P2P网络。根据模拟的方式不同，在4GB的内存情况下，支持模拟十万到千万个节点级别。其本身并没有实现任何具体的协议，但是提供了很好的扩展性，研究人员已经在其基础上实现了各种流行的P2P协议，官方网站上也提供下载。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.PeerSim 下载与运行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;PeerSim实际上是一个java的工程，我们可以在其官方网站上下载源代码，官网链接为:
&lt;a class="reference external" href="http://peersim.sourceforge.net/"&gt;PeerSim: A Peer-to-Peer Simulator&lt;/a&gt;
，下载并解压得到一个名为
&lt;strong&gt;peersim-1.0.5的文件夹&lt;/strong&gt;
。&lt;/p&gt;
&lt;p&gt;由于PeerSim是用java编写的，学习如何时需要经常阅读源代码，所以推荐使用Eclipse来运行(当然高手也可以直接通过命令行来运行)。
这里也只说明如何在Eclipse环境下运行PeerSim。&lt;/p&gt;
&lt;p&gt;1&amp;gt; 新建java工程，命名例如PeerSim_t。&lt;/p&gt;
&lt;p&gt;2&amp;gt; 将peersim-1.0.5中的src文件夹内的全部内容(包括两个包，peersim和example)拖入工程的src文件夹下。&lt;/p&gt;
&lt;p&gt;3&amp;gt; 将peersim-1.0.5中的三个jar包(peersim-1.0.5.jar, djep-1.0.0.jar, jep-2.3.0.jar)拖入工程并build path添加到工程内，如下图所示:&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="../statics/pics/peersim_tutorial_1.png" src="../statics/pics/peersim_tutorial_1.png" /&gt;
&lt;/div&gt;
&lt;p&gt;(文件夹内还有一个jar包peersim-doclet.jar，添加后运行时会出错，不知道这个jar有何用处)&lt;/p&gt;
&lt;p&gt;4&amp;gt; peersim-1.0.5中的example文件夹内有4个配置文件的样例，以config-example1.txt为例，将其拖入工程根目录下。&lt;/p&gt;
&lt;p&gt;5&amp;gt; 找到工程中的peersim包，鼠标右键包内的Simulator.java，点击Run As -&amp;gt; Run Configurations，在Arguments中填入配置文件的文件名(config-example1.txt)，点击Run，就可以看到模拟器运行样例了。&lt;/p&gt;
&lt;p&gt;至此，就可以将一个peersim模拟成功运行起来了。&lt;/p&gt;
</summary><category term="PeerSim"></category><category term="P2P"></category></entry><entry><title>tesseract-ocr使用方法总结</title><link href="http://hyhx2008.github.com/tesseract-ocrshi-yong-fang-fa-zong-jie.html" rel="alternate"></link><updated>2012-12-01T16:34:00+09:00</updated><author><name>hyhx2008</name></author><id>tag:hyhx2008.github.com,2012-12-01:tesseract-ocrshi-yong-fang-fa-zong-jie.html</id><summary type="html">&lt;p&gt;实习的时候接触到了一个挺不错的OCR(光学字符识别)工具tesseract，这里总结一下linux下tesseract的简单用法。&lt;/p&gt;
&lt;p&gt;tesseract-ocr是由google维护的一个开源ocr库，可以识别多种格式图片中的文字，可以直接作为一个工具使用，也可以利用tesseract提供的api在自己的程序中使用ocr功能。&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://code.google.com/p/tesseract-ocr/"&gt;项目主页&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.tesseract-ocr安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ubuntu和debian下tesseract的安装非常简单，但是需要安装的包比较多:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;sudo aptitude install tesseract-ocr tesseract-ocr-dev tesseract-ocr-eng
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;tesseract-ocr即为ocr库，tesseract-ocr-dev是使用api时需要用到的头文件。&lt;/p&gt;
&lt;p&gt;tesseract-ocr-eng是语言包，这里安装的是英文，如果要识别其他语言，需要安装其他语言包。&lt;/p&gt;
&lt;p&gt;（语言包安装的位置在/usr/share/tesseract-ocr/tessdata/，该位置将作为初始化api的一个参数）&lt;/p&gt;
&lt;p&gt;为了识别tiff格式的图片，最好再安装以下两个库:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;sudo aptitude install leptonica libtiff
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样tesseract-ocr和一些相关的包就安装完成了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.tesseract-ocr使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作为一个命令行程序，tesseract可以用以下命令识别一张图片中的文字:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="go"&gt;tesseract photo.tif 1.txt&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上命令将从photo.tif中识别的文字存储在1.txt中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.tesseract api 使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;tesseract现在已经出到3.0.1版本了，网上的资料也大多基于3.0.1版本，比如
&lt;a class="reference external" href="http://www.cnblogs.com/zsb517/archive/2012/06/06/2537540.html"&gt;Tesseract3.01在VS2008下面的使用&lt;/a&gt; 和
&lt;a class="reference external" href="http://blog.csdn.net/foxwit/article/details/6547465"&gt;OCR识别引擎tesseract使用方法&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;不幸的是，Debian下安装的是2.0.4版本，api的命名与用法和新版本有所不同。在项目主页上我也没有找到api的使用手册之类的东西，只能自己琢磨。&lt;/p&gt;
&lt;p&gt;我发现查看tesseract的source code是一个很好的学习api用法的途径，源码可以在下面的链接中下载:
&lt;a class="reference external" href="http://code.google.com/p/tesseract-ocr/downloads/detail?name=tesseract-2.04.tar.gz&amp;amp;can=2&amp;amp;q="&gt;tesseract 2.0.4 Source&lt;/a&gt;
，
&lt;a class="reference external" href="http://code.google.com/p/tesseract-ocr/downloads/detail?name=tesseract-3.01.tar.gz&amp;amp;can=2&amp;amp;q="&gt;tesseract 3.0.1 Source&lt;/a&gt;
。&lt;/p&gt;
&lt;p&gt;下载并解压后在ccmain文件夹中的
&lt;strong&gt;tesseractmain.cpp&lt;/strong&gt;
就是tesseract工具的主程序，是很好的api用法参考。api的声明在
&lt;strong&gt;baseapi.h&lt;/strong&gt;
中(ccmain中或/usr/include下都可以找到)。&lt;/p&gt;
&lt;p&gt;所有需要include的头文件都在 /usr/include/tesseract 和 /usr/include/lptonica 中，需要链接的库在/usr/lib中。&lt;/p&gt;
&lt;p&gt;api的具体用法参见后面附的源码的注释。&lt;/p&gt;
&lt;p&gt;编译真的是最痛苦的事情，不清楚需要链接哪些库，于是/usr/lib里用下面的命令找到相关的库，全都链接进来:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;ls | grep tesseract
&lt;span class="gp"&gt;$&lt;/span&gt;ls | grep leptonica
&lt;span class="gp"&gt;$&lt;/span&gt;ls | grep tiff
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果编译还是不通过，提示一大堆未定义的函数，发现都和png有关系，于是又用&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;ls | grep png
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;找到一个库链接后才编译成功。我编译用的Makefile附在最后。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.api使用的例子&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新建一个ocr_test.cpp文件，将下面的代码粘贴进去即可。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;mfcpch.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;ctype.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;applybox.h&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;control.h&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;tessvars.h&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;tessedit.h&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;baseapi.h&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;pageres.h&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;imgs.h&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;varabled.h&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;tprintf.h&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;stderr.h&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;notdll.h&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;mainblk.h&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;output.h&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;globals.h&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;blread.h&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;tfacep.h&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;callnet.h&amp;quot;&lt;/span&gt;


&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;usage:%s &amp;lt;tiff file&amp;gt; &amp;lt;txt file&amp;gt;/n&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
                &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;image_file&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;       &lt;span class="c1"&gt;//程序的第一个参数为图片路径&lt;/span&gt;
        &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;txt_file&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;         &lt;span class="c1"&gt;//第二个参数为保存识别出的字符的文件路径&lt;/span&gt;

        &lt;span class="n"&gt;STRING&lt;/span&gt; &lt;span class="n"&gt;text_out&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                        &lt;span class="c1"&gt;//存储识别出的字符&lt;/span&gt;

        &lt;span class="n"&gt;TessBaseAPI&lt;/span&gt;  &lt;span class="n"&gt;api&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;IMAGE&lt;/span&gt; &lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="n"&gt;api&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SimpleInit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;/usr/share/tesseract-ocr/tessdata/&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kc"&gt;false&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 初始化函数，tesseract还提供其他的初始化函数 参考 baseapi.h&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read_header&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;read image header error!&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_ysize&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;read image error!&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="c1"&gt;//读取图片并判断是否读取成功&lt;/span&gt;

        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;bytes_per_line&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;check_legal_image_size&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_xsize&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_ysize&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_bpp&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;

        &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;api&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;TesseractRect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_buffer&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_bpp&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;bytes_per_line&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_xsize&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_ysize&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
        &lt;span class="c1"&gt;//tesseract核心api，通过该函数识别出图片中的字符&lt;/span&gt;

        &lt;span class="n"&gt;text_out&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;output: %s&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="n"&gt;FILE&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;fout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fopen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;txt_file&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;w&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="n"&gt;fwrite&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;text_out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;text_out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;fout&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="n"&gt;fclose&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fout&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;5.编译并运行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新建Makefile如下所示。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="go"&gt;LDFLAGS= -ltesseract_full -ltesseract_pageseg -ltesseract_training -ltesseract_textord -ltesseract_wordrec -ltesseract_classify -ltesseract_dict -ltesseract_ccstruct -ltesseract_cutil -ltesseract_viewer -ltesseract_ccutil -ltesseract_image -ltesseract_main -llept -ltiff -ltiffxx -lpthread -lpng -lpng12&lt;/span&gt;

&lt;span class="go"&gt;INCLUDES= -I/usr/include/tesseract/ -I/usr/include/leptonica/&lt;/span&gt;

&lt;span class="go"&gt;all:ocr&lt;/span&gt;

&lt;span class="go"&gt;ocr:&lt;/span&gt;
&lt;span class="go"&gt;        g++ -g -o ocr ocr_test.cpp $(LDFLAGS) $(INCLUDES)&lt;/span&gt;

&lt;span class="go"&gt;clean:&lt;/span&gt;
&lt;span class="go"&gt;        rm ocr&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用下面的命令运行样例程序:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;make
&lt;span class="gp"&gt;$&lt;/span&gt;ocr photo.tif 1.txt
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The End!!&lt;/p&gt;
</summary><category term="ocr Linux"></category></entry><entry><title>让google和百度检索自己的网站</title><link href="http://hyhx2008.github.com/rang-googlehe-bai-du-jian-suo-zi-ji-de-wang-zhan.html" rel="alternate"></link><updated>2012-11-18T23:58:00+09:00</updated><author><name>hyhx2008</name></author><id>tag:hyhx2008.github.com,2012-11-18:rang-googlehe-bai-du-jian-suo-zi-ji-de-wang-zhan.html</id><summary type="html">&lt;p&gt;自从建立起github博客也有两个星期了，但是在google上一直搜索不到自己的博客。&lt;/p&gt;
&lt;p&gt;等了这么久google还没有抓取我的博客内容。今天问了马星这个问题，马星又早就把解决办法贴在他的
&lt;a class="reference external" href="http://x-wei.github.com/add-google-custom-search.html"&gt;blog&lt;/a&gt;
上了。。&lt;/p&gt;
&lt;p&gt;其实可以主动向搜索引擎申请检索自己的网站，申请链接如下:&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://www.google.com/addurl/?hl=zh-CN&amp;amp;continue=/addurl"&gt;google: http://www.google.com/addurl/?hl=zh-CN&amp;amp;continue=/addurl&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://www.baidu.com/search/url_submit.html"&gt;baidu: http://www.baidu.com/search/url_submit.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;填写自己的网址即可。&lt;/p&gt;
&lt;p&gt;(问完马星才发现google好像几天前已经检索了我的博客内容。。。)&lt;/p&gt;
&lt;p&gt;马星那那篇
&lt;a class="reference external" href="http://x-wei.github.com/add-google-custom-search.html"&gt;blog&lt;/a&gt;
上还讲了如何添加google自定义搜索，不过要使用bootsrap2主题。。&lt;/p&gt;
&lt;p&gt;我瞎折腾了一会儿，也在左边添加了个畸形的自定义搜索框。。。&lt;/p&gt;
&lt;p&gt;The End！！&lt;/p&gt;
</summary><category term="google"></category><category term="baidu"></category></entry><entry><title>VMware虚拟机启动时总提示cann't connect to floopy0的问题</title><link href="http://hyhx2008.github.com/vmwarexu-ni-ji-qi-dong-shi-zong-ti-shi-cannt-connect-to-floopy0de-wen-ti.html" rel="alternate"></link><updated>2012-11-13T17:26:00+09:00</updated><author><name>hyhx2008</name></author><id>tag:hyhx2008.github.com,2012-11-13:vmwarexu-ni-ji-qi-dong-shi-zong-ti-shi-cannt-connect-to-floopy0de-wen-ti.html</id><summary type="html">&lt;p&gt;在VMware中装了ubuntu，启动时总提示不能连接到设备floopy0，关也关不掉，很讨厌。&lt;/p&gt;
&lt;p&gt;百度了一下解决办法: 修改虚拟机的.vmx文件。&lt;/p&gt;
&lt;p&gt;1.将floppy0.autodetect这项改为FALSE:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="go"&gt;floppy0.autodetect = &amp;quot;FALSE&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.添加一句:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="go"&gt;floppy0.startConnected = &amp;quot;FALSE&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The End!!&lt;/p&gt;
</summary><category term="ubuntu"></category><category term="VMware"></category></entry><entry><title>使用pelican生成github博客</title><link href="http://hyhx2008.github.com/shi-yong-pelicansheng-cheng-githubbo-ke.html" rel="alternate"></link><updated>2012-11-11T22:20:00+09:00</updated><author><name>hyhx2008</name></author><id>tag:hyhx2008.github.com,2012-11-11:shi-yong-pelicansheng-cheng-githubbo-ke.html</id><summary type="html">&lt;p&gt;自从马星给我推荐在github上写博客到现在已经好久了，今天我终于算是学会了。
我看人家都是用jekyll生成静态页面的，果然和专业到技术宅差得太多，自己尝试折腾了一天也没弄出什么名堂。
马星觉得自己很菜，我居然比马星还菜。。。。。
在马星的诱惑下，用了这个不知到他从哪找来的工具，说实话倒是挺好用的。&lt;/p&gt;
&lt;p&gt;这里记录一下生成博客的步骤（以下内容大多copy自
&lt;a class="reference external" href="http://x-wei.github.com/pelican_github_blog.html"&gt;马星的blog&lt;/a&gt;
）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.配置git&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;注册github后首先要配置git。可以参考
&lt;a class="reference external" href="https://help.github.com/articles/set-up-git#platform-linux"&gt;github:help:set up git&lt;/a&gt;
。&lt;/p&gt;
&lt;p&gt;设置用户名和邮箱，邮箱为注册github时的邮箱地址。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;git config --global user.name &lt;span class="s2"&gt;&amp;quot;hy&amp;quot;&lt;/span&gt;

&lt;span class="gp"&gt;$&lt;/span&gt;git config --global user.email &lt;span class="s2"&gt;&amp;quot;hyxxxxxx@163.com&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以用下面的命令查看配置。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;git config -l
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;github上说可以用https方法提交工程，但是没有成功过，所以还是需要利用ssh。这里需要生成ssh keys，
具体步骤参考
&lt;a class="reference external" href="https://help.github.com/articles/generating-ssh-keys#platform-linux"&gt;github:help:generating ssh keys&lt;/a&gt;
。&lt;/p&gt;
&lt;p&gt;然后就可以进行git clone 和 git push等操作了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.生成github page&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;需要在github上新建一个仓库(repository)，这个仓库的名称必须为
&lt;strong&gt;your_id.github.com&lt;/strong&gt;
。然后将一个index.html文件上传到master分支后，就可以访问域名your_id.github.com看到自己的主页了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.安装和使用pelican&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;pelican安装需要用到python-pip:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;sudo aptitude install python-pip
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后再用pip安装python:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;sudo pip install pelican
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样pelican就安装完成了。&lt;/p&gt;
&lt;p&gt;pelican的使用也很简单, 需要在仓库根目录下新建一个配置文件settings.py, 内容大概如下所示:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;

&lt;span class="n"&gt;TIMEZONE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Asia/Tokyo&amp;#39;&lt;/span&gt;

&lt;span class="n"&gt;DEFAULT_LANG&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;zhs&amp;#39;&lt;/span&gt;

&lt;span class="n"&gt;SITENAME&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;H.y&amp;#39;s Blog&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;AUTHOR&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;hyhx2008&amp;#39;&lt;/span&gt;

&lt;span class="n"&gt;DISQUS_SITENAME&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;hysblog&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;GITHUB_URL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;https://github.com/hyhx2008&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;SITEURL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;http://hyhx2008.github.com&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;GOOGLE_ANALYTICS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;UA-36075477-1&amp;#39;&lt;/span&gt;
&lt;span class="c"&gt;#TAG_FEED_ATOM = &amp;#39;feeds/%s.atom.xml&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;TAG_CLOUD_STEPS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;
&lt;span class="n"&gt;FEED_RSS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;feeds/all.rss.xml&amp;#39;&lt;/span&gt;
&lt;span class="c"&gt;#DEFAULT_ORPHANS=3&lt;/span&gt;
&lt;span class="n"&gt;DEFAULT_PAGINATION&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;
&lt;span class="n"&gt;DELETE_OUTPUT_DIRECTORY&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;
&lt;span class="n"&gt;DEFAULT_CATEGORY&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;tech&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;OUTPUT_PATH&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;.&amp;#39;&lt;/span&gt;

&lt;span class="n"&gt;PATH&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;posts&amp;#39;&lt;/span&gt;

&lt;span class="n"&gt;THEME&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;./pelican-themes/bootstrap&amp;#39;&lt;/span&gt;


&lt;span class="n"&gt;LINKS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;x-wei&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;http://x-wei.github.com&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;farseerfc&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;http://farseerfc.github.com/&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
                          &lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;SOCIAL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;github&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;https://github.com/hyhx2008&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
                            &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;各项的含义可以参见
&lt;a class="reference external" href="https://pelican.readthedocs.org/en/2.8/settings.html"&gt;pelican:settings&lt;/a&gt;
。&lt;/p&gt;
&lt;p&gt;settings.py中有一项PAHT=`posts`, 指的是放置reST格式文件的目录，所以新建一个posts文件夹，然后将博客用
&lt;a class="reference external" href="http://docutils.sourceforge.net/rst.html"&gt;reST&lt;/a&gt;
格式写好之后放在posts文件夹下，即可用pelican生成静态页面了。在仓库根目录下用:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;pelican -s settings.py
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后就可以看到生成的index.html了。&lt;/p&gt;
&lt;p&gt;pelican还可以使用现成的模版，主题可以在github上下载:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;git clone https://github.com/farseerfc/pelican-themes
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;settings.py中的THEME项用来指定要使用的主题模版。&lt;/p&gt;
&lt;p&gt;如果和我一样觉得麻烦的话，可以在github上clone一个现成的博客修改学习，比如:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;git clone git@github.com:hyhx2008/hyhx2008.github.com.git
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;4.将博客上传到github&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用以下三条命令:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;git add .
&lt;span class="gp"&gt;$&lt;/span&gt;git commit -a -m &lt;span class="s2"&gt;&amp;quot;commit message&amp;quot;&lt;/span&gt;
&lt;span class="gp"&gt;$&lt;/span&gt;git push origin master
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;收到一封页面修改成功的邮件后，就可以到自己的主页 your_id.github.com 查看了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.关于reST格式文件的编辑&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;pelican支持markdown和reST两种格式，由于reST的语法高亮比较容易，马星推荐我使用这个格式。附上两个教程:
&lt;a class="reference external" href="https://beinggeekbook.readthedocs.org/en/latest/rst.html"&gt;中文教程&lt;/a&gt;
,
&lt;a class="reference external" href="http://docutils.sourceforge.net/rst.html"&gt;官方英文教程&lt;/a&gt;
。&lt;/p&gt;
&lt;p&gt;在linux环境下可以使用具有实时预览功能的ReText编辑器编辑reST文件，但是后来发现vim中支持reST文件的语法高亮，写起来也挺方便的。&lt;/p&gt;
&lt;p&gt;The End!&lt;/p&gt;
</summary><category term="GitHub"></category><category term="pelican"></category></entry><entry><title>重新安装ubuntu后的todo list</title><link href="http://hyhx2008.github.com/ubuntu_reinstall_todo-zh.html" rel="alternate"></link><updated>2012-11-11T21:44:00+09:00</updated><author><name>hyhx2008</name></author><id>tag:hyhx2008.github.com,2012-11-11:ubuntu_reinstall_todo-zh.html</id><summary type="html">&lt;p&gt;经常把虚拟机里ubuntu搞坏，重装后总记不清还要做什么设置，安什么软件。&lt;/p&gt;
&lt;p&gt;写在这里做个提醒吧，以后再慢慢添加。&lt;/p&gt;
&lt;p&gt;1.安装aptitude&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;sudo apt-get install aptitude
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.安装vim&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;sudo aptitude install vim
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;并修改/usr/share/vim/vimrc 。&lt;/p&gt;
&lt;p&gt;3.添加sudoers&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;sudo visudo
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;加入 hy ALL = （ALL）ALL。&lt;/p&gt;
&lt;p&gt;ubuntu下好像这样做后还是不能使用su命令切换到root，百度解决办法:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;sudo passwd
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改一下密码就好了。&lt;/p&gt;
&lt;p&gt;4.安装openssh&lt;/p&gt;
&lt;p&gt;为了能让secureCRT连上虚拟机里的ubuntu，需要安装openssh。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;sudo aptitude install openssh-server openssh-client
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再用ifconfig查一下ip，填到secureCRT里就好了。&lt;/p&gt;
&lt;p&gt;5.安装中文输入法&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;sudo aptitude install ibus ibus-pinyin ibus-gtk ibus-qt4
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;暂时想到这么多。。。。&lt;/p&gt;
</summary><category term="ubuntu"></category></entry><entry><title>Hello World!</title><link href="http://hyhx2008.github.com/hello-world.html" rel="alternate"></link><updated>2012-11-11T02:16:00+09:00</updated><author><name>hyhx2008</name></author><id>tag:hyhx2008.github.com,2012-11-11:hello-world.html</id><summary type="html">&lt;p&gt;终于建立起了我的github博客~!&lt;/p&gt;
&lt;p&gt;感谢马星手把手一步一步教我如何在github上写博客。&lt;/p&gt;
&lt;p&gt;说是博客，其实估计也没人看，就当做记笔记写总结到好地方了。&lt;/p&gt;
&lt;p&gt;以前都是用evernote写笔记的，但是在粘代码的时候不能语法高亮，所以听了马星的推荐在github上写博客，也算是赶个时髦吧～&lt;/p&gt;
</summary><category term="GitHub"></category></entry><entry><title>Festival tts 使用总结</title><link href="http://hyhx2008.github.com/festival-tts-shi-yong-zong-jie.html" rel="alternate"></link><updated>2012-08-24T22:00:00+09:00</updated><author><name>hyhx2008</name></author><id>tag:hyhx2008.github.com,2012-08-24:festival-tts-shi-yong-zong-jie.html</id><summary type="html">&lt;p&gt;&lt;a class="reference external" href="http://www.cstr.ed.ac.uk/projects/festival/"&gt;Festival-tts&lt;/a&gt;
是一个免费的tts (text to speech) 工具，可以将字符串转为声音播放出来或者存为声音文件。&lt;/p&gt;
&lt;p&gt;首先安装:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;sodu aptitude install festival
&lt;span class="gp"&gt;$&lt;/span&gt;sudo aptitude install festival-dev
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以用下面的命令测试一下:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;&lt;span class="nb"&gt;echo &lt;/span&gt;hellow world | festival --tts
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时可以听到喇叭中念出hello world，如果没有声音可能是声卡驱动的问题。&lt;/p&gt;
&lt;p&gt;如果想在自己的程序中使用festival tts的功能，则需要用到festival提供的API，可以参考festiva的文档:
&lt;a class="reference external" href="http://www.cstr.ed.ac.uk/projects/festival/manual/festival_28.html#SEC126"&gt;festival:API&lt;/a&gt;
。&lt;/p&gt;
&lt;p&gt;这里以C++的API为例，介绍两个常用的函数。&lt;/p&gt;
&lt;p&gt;首先程序需要include一个头文件:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;festival.h&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;两个常用API为:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;festival_initialize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;load_init_files&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;heap_size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="n"&gt;festival_say_text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从函数名就可以看出这两个API的作用，第一个为初始化函数，需要在使用其他API之前调用，第二个函数即将text转为声音播放出来。&lt;/p&gt;
&lt;p&gt;下面给出一个样例程序，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;festival/festival.h&amp;gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;

        &lt;span class="c1"&gt;//EST_Wave wave;&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;heap_size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;210000&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// default scheme heap size&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;load_init_files&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// we want the festival init files loaded&lt;/span&gt;

        &lt;span class="n"&gt;festival_initialize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;load_init_files&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;heap_size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="c1"&gt;// Say simple file&lt;/span&gt;
        &lt;span class="c1"&gt;//festival_say_file(&amp;quot;/etc/motd&amp;quot;);&lt;/span&gt;

        &lt;span class="c1"&gt;//festival_eval_command(&amp;quot;(voice_ked_diphone)&amp;quot;);&lt;/span&gt;

        &lt;span class="c1"&gt;// Say some text;&lt;/span&gt;
        &lt;span class="n"&gt;festival_say_text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;hello world&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="c1"&gt;// Convert to a waveform&lt;/span&gt;
        &lt;span class="c1"&gt;//festival_text_to_wave(&amp;quot;hello world&amp;quot;,wave);&lt;/span&gt;

        &lt;span class="c1"&gt;//wave.save(&amp;quot;/tmp/wave.wav&amp;quot;,&amp;quot;riff&amp;quot;);&lt;/span&gt;
        &lt;span class="c1"&gt;// festival_say_file puts the system in async mode so we better&lt;/span&gt;
        &lt;span class="c1"&gt;// wait for the spooler to reach the last waveform before exiting&lt;/span&gt;
        &lt;span class="c1"&gt;// This isn&amp;#39;t necessary if only festival_say_text is being used (and your own wave playing stuff)&lt;/span&gt;

        &lt;span class="c1"&gt;//festival_wait_for_spooler();&lt;/span&gt;

        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其他一些可用的API被我注释掉了，感兴趣的话可以尝试一下。&lt;/p&gt;
&lt;p&gt;程序很简单，麻烦的是编译，需要include很多头文件并连接一大堆库，搞了半天才可以编译通过，下面的编译命令供参考:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="go"&gt;g++ festival_src.cpp -o festival_app -lpthread -lFestival -I/usr/include/festival -I/usr/include/speech_tools -L/usr/lib/speech_tools/lib -lestools -lestbase -leststring&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The End!!&lt;/p&gt;
</summary><category term="festival"></category></entry><entry><title>trace-cmd与kernelshark使用总结</title><link href="http://hyhx2008.github.com/trace-cmdyu-kernelsharkshi-yong-zong-jie.html" rel="alternate"></link><updated>2012-07-22T22:00:00+09:00</updated><author><name>hyhx2008</name></author><id>tag:hyhx2008.github.com,2012-07-22:trace-cmdyu-kernelsharkshi-yong-zong-jie.html</id><summary type="html">&lt;p&gt;&lt;strong&gt;1.trace-cmd&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;trace-cmd是对ftrace的封装，是一个可以用来跟踪linux内核中事件(event)发生的时间、次数等的工具。&lt;/p&gt;
&lt;p&gt;首先需要安装trace-cmd:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;sudo aptitude install trace-cmd
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用也非常简单:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;sudo trace-cmd record -e sched_switch
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;-e 参数指出需要跟踪的事件，这里的sched_switch指的是进程切换，还可以是hrtimer、irq等，例如:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;sudo trace-cmd record -e sched_switch -e hrtimer*
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;命令输完回车后，trace-cmd就开始记录内核中事件的发生了，ctrl+C 停止跟踪，此时会生成一个trace.dat文件，相当于一个log吧。&lt;/p&gt;
&lt;p&gt;trace.dat里的内容不易读，trace-cmd提供分析trace.dat的功能:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;trace-cmd report
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;就可以看到所跟踪的事件发生的情况了，和下图差不多。&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="../statics/pics/trace_cmd_kernelshark1.png" src="../statics/pics/trace_cmd_kernelshark1.png" /&gt;
&lt;/div&gt;
&lt;p&gt;也可以重定向到一个文本文件中再做分析，比如:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;trace-cmd report &amp;gt; report.txt
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;跟踪的报告就存入report.txt中了，可以用Perl等来处理。&lt;/p&gt;
&lt;p&gt;注:使用trace-cmd需要内核开启ftrace，即在编译内核make menuconfig时，选择下面的选项:&lt;/p&gt;
&lt;p&gt;Kernel Hacking -&amp;gt; Tracers -&amp;gt; Kernel Function Tracer&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.kernelshark&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;kernelshark提供了对trace.dat的可视化分析，首先安装:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;sudo aptitude install kernelshark
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后在trace.dat所在的目录输入:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;kernelshark
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;即可看到图形化界面了:&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="../statics/pics/trace_cmd_kernelshark2.png" src="../statics/pics/trace_cmd_kernelshark2.png" /&gt;
&lt;/div&gt;
&lt;p&gt;The End!!&lt;/p&gt;
</summary><category term="trace-cmd"></category><category term="kernelshark"></category></entry><entry><title>Linux内核编译步骤</title><link href="http://hyhx2008.github.com/linuxnei-he-bian-yi-bu-zou.html" rel="alternate"></link><updated>2012-07-18T22:00:00+09:00</updated><author><name>hyhx2008</name></author><id>tag:hyhx2008.github.com,2012-07-18:linuxnei-he-bian-yi-bu-zou.html</id><summary type="html">&lt;p&gt;实习的时候需要用到3.0.35-rt56版本的linux内核，这里总结一下Debian下Linux内核编译的步骤, ubuntu下可能略有不同。&lt;/p&gt;
&lt;p&gt;首先进入到内核源码的目录，然后按照以下步骤编译:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.配置内核&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;make menuconfig
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这条命令可以在一个GUI下设置用户需要的内核参数，并生成编译需要的.config配置文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.编译内核&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;make -j 2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;后面的-j参数指的是可以允许多少个module同时编译，-j 2 就是允许2个module同时编译，也可以省略-j参数。如果CPU是多核的话，可以加上该参数提高编译速度。&lt;/p&gt;
&lt;p&gt;接下来就是漫长的等待。。。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.加入模块&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;sudo make modules_install
&lt;span class="gp"&gt;$&lt;/span&gt;sudo make install
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;4.更新引导文件&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;sudo update-initramfs -c -k &lt;span class="s2"&gt;&amp;quot;kernel version&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的kernel version可以在make menuconfig的时候自己设置名称，具体应该写什么需要在/boot文件夹下查看:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;ls -lF /boot
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;比如内核版本为2.6.36，则/boot下就会有一个vmlinuz-2.6.36文件，把vmlinuz-后面的字符放在kernel version的位置即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.更新grub&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;sudo update-grub
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;整个编译过程大概也得一两个小时左右吧，耐心等待。&lt;/p&gt;
&lt;p&gt;The End！！&lt;/p&gt;
</summary><category term="linux"></category><category term="kernel"></category><category term="compile"></category></entry></feed>