<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>H.y's Blog</title><link>http://hyhx2008.github.com/</link><description></description><atom:link href="http://hyhx2008.github.com/feeds/all.rss.xml" rel="self"></atom:link><lastBuildDate>Wed, 20 Mar 2013 13:40:00 +0900</lastBuildDate><item><title>PeerSim使用教程(1)-入门</title><link>http://hyhx2008.github.com/peersimshi-yong-jiao-cheng-1-ru-men.html</link><description>&lt;p&gt;最近一年所谓的研究几乎没有什么大的收获，研究的题目也一直局限在P2P，除了水文一篇，最大的收获就是学会使用PeerSim这个P2P模拟器。在这里总结一下PeerSim的使用方法，以此来结束对P2P的研究。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.PeerSim简介&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;PeerSim是一个用java编写的P2P overlay Network的模拟器，可以模拟结构化和非结构化的P2P网络。根据模拟的方式不同，在4GB的内存情况下，支持模拟十万到千万个节点级别。其本身并没有实现任何具体的协议，但是提供了很好的扩展性，研究人员已经在其基础上实现了各种流行的P2P协议，官方网站上也提供下载。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.PeerSim 下载与运行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;PeerSim实际上是一个java的工程，我们可以在其官方网站上下载源代码，官网链接为:
&lt;a class="reference external" href="http://peersim.sourceforge.net/"&gt;PeerSim: A Peer-to-Peer Simulator&lt;/a&gt;
，下载并解压得到一个名为
&lt;strong&gt;peersim-1.0.5的文件夹&lt;/strong&gt;
。&lt;/p&gt;
&lt;p&gt;由于PeerSim是用java编写的，学习如何时需要经常阅读源代码，所以推荐使用Eclipse来运行(当然高手也可以直接通过命令行来运行)。
这里也只说明如何在Eclipse环境下运行PeerSim。&lt;/p&gt;
&lt;p&gt;1&amp;gt; 新建java工程，命名例如PeerSim_t。&lt;/p&gt;
&lt;p&gt;2&amp;gt; 将peersim-1.0.5中的src文件夹内的全部内容(包括两个包，peersim和example)拖入工程的src文件夹下。&lt;/p&gt;
&lt;p&gt;3&amp;gt; 将peersim-1.0.5中的三个jar包(peersim-1.0.5.jar, djep-1.0.0.jar, jep-2.3.0.jar)拖入工程并build path添加到工程内，如下图所示:&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="../statics/pics/peersim_tutorial_1.png" src="../statics/pics/peersim_tutorial_1.png" /&gt;
&lt;/div&gt;
&lt;p&gt;(文件夹内还有一个jar包peersim-doclet.jar，添加后运行时会出错，不知道这个jar有何用处)&lt;/p&gt;
&lt;p&gt;4&amp;gt; peersim-1.0.5中的example文件夹内有4个配置文件的样例，以config-example1.txt为例，将其拖入工程根目录下。&lt;/p&gt;
&lt;p&gt;5&amp;gt; 找到工程中的peersim包，鼠标右键包内的Simulator.java，点击Run As -&amp;gt; Run Configurations，在Arguments中填入配置文件的文件名(config-example1.txt)，点击Run，就可以看到模拟器运行样例了。&lt;/p&gt;
&lt;p&gt;至此，就可以将一个peersim模拟成功运行起来了。&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">hyhx2008</dc:creator><pubDate>Wed, 20 Mar 2013 13:40:00 +0900</pubDate><guid>tag:hyhx2008.github.com,2013-03-20:peersimshi-yong-jiao-cheng-1-ru-men.html</guid><category>PeerSim</category><category>P2P</category></item><item><title>tesseract-ocr使用方法总结</title><link>http://hyhx2008.github.com/tesseract-ocrshi-yong-fang-fa-zong-jie.html</link><description>&lt;p&gt;实习的时候接触到了一个挺不错的OCR(光学字符识别)工具tesseract，这里总结一下linux下tesseract的简单用法。&lt;/p&gt;
&lt;p&gt;tesseract-ocr是由google维护的一个开源ocr库，可以识别多种格式图片中的文字，可以直接作为一个工具使用，也可以利用tesseract提供的api在自己的程序中使用ocr功能。&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://code.google.com/p/tesseract-ocr/"&gt;项目主页&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.tesseract-ocr安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ubuntu和debian下tesseract的安装非常简单，但是需要安装的包比较多:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;sudo aptitude install tesseract-ocr tesseract-ocr-dev tesseract-ocr-eng
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;tesseract-ocr即为ocr库，tesseract-ocr-dev是使用api时需要用到的头文件。&lt;/p&gt;
&lt;p&gt;tesseract-ocr-eng是语言包，这里安装的是英文，如果要识别其他语言，需要安装其他语言包。&lt;/p&gt;
&lt;p&gt;（语言包安装的位置在/usr/share/tesseract-ocr/tessdata/，该位置将作为初始化api的一个参数）&lt;/p&gt;
&lt;p&gt;为了识别tiff格式的图片，最好再安装以下两个库:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;sudo aptitude install leptonica libtiff
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样tesseract-ocr和一些相关的包就安装完成了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.tesseract-ocr使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作为一个命令行程序，tesseract可以用以下命令识别一张图片中的文字:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="go"&gt;tesseract photo.tif 1.txt&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上命令将从photo.tif中识别的文字存储在1.txt中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.tesseract api 使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;tesseract现在已经出到3.0.1版本了，网上的资料也大多基于3.0.1版本，比如
&lt;a class="reference external" href="http://www.cnblogs.com/zsb517/archive/2012/06/06/2537540.html"&gt;Tesseract3.01在VS2008下面的使用&lt;/a&gt; 和
&lt;a class="reference external" href="http://blog.csdn.net/foxwit/article/details/6547465"&gt;OCR识别引擎tesseract使用方法&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;不幸的是，Debian下安装的是2.0.4版本，api的命名与用法和新版本有所不同。在项目主页上我也没有找到api的使用手册之类的东西，只能自己琢磨。&lt;/p&gt;
&lt;p&gt;我发现查看tesseract的source code是一个很好的学习api用法的途径，源码可以在下面的链接中下载:
&lt;a class="reference external" href="http://code.google.com/p/tesseract-ocr/downloads/detail?name=tesseract-2.04.tar.gz&amp;amp;can=2&amp;amp;q="&gt;tesseract 2.0.4 Source&lt;/a&gt;
，
&lt;a class="reference external" href="http://code.google.com/p/tesseract-ocr/downloads/detail?name=tesseract-3.01.tar.gz&amp;amp;can=2&amp;amp;q="&gt;tesseract 3.0.1 Source&lt;/a&gt;
。&lt;/p&gt;
&lt;p&gt;下载并解压后在ccmain文件夹中的
&lt;strong&gt;tesseractmain.cpp&lt;/strong&gt;
就是tesseract工具的主程序，是很好的api用法参考。api的声明在
&lt;strong&gt;baseapi.h&lt;/strong&gt;
中(ccmain中或/usr/include下都可以找到)。&lt;/p&gt;
&lt;p&gt;所有需要include的头文件都在 /usr/include/tesseract 和 /usr/include/lptonica 中，需要链接的库在/usr/lib中。&lt;/p&gt;
&lt;p&gt;api的具体用法参见后面附的源码的注释。&lt;/p&gt;
&lt;p&gt;编译真的是最痛苦的事情，不清楚需要链接哪些库，于是/usr/lib里用下面的命令找到相关的库，全都链接进来:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;ls | grep tesseract
&lt;span class="gp"&gt;$&lt;/span&gt;ls | grep leptonica
&lt;span class="gp"&gt;$&lt;/span&gt;ls | grep tiff
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果编译还是不通过，提示一大堆未定义的函数，发现都和png有关系，于是又用&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;ls | grep png
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;找到一个库链接后才编译成功。我编译用的Makefile附在最后。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.api使用的例子&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新建一个ocr_test.cpp文件，将下面的代码粘贴进去即可。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;mfcpch.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;ctype.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;applybox.h&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;control.h&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;tessvars.h&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;tessedit.h&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;baseapi.h&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;pageres.h&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;imgs.h&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;varabled.h&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;tprintf.h&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;stderr.h&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;notdll.h&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;mainblk.h&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;output.h&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;globals.h&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;blread.h&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;tfacep.h&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;callnet.h&amp;quot;&lt;/span&gt;


&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;usage:%s &amp;lt;tiff file&amp;gt; &amp;lt;txt file&amp;gt;/n&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
                &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;image_file&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;       &lt;span class="c1"&gt;//程序的第一个参数为图片路径&lt;/span&gt;
        &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;txt_file&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;         &lt;span class="c1"&gt;//第二个参数为保存识别出的字符的文件路径&lt;/span&gt;

        &lt;span class="n"&gt;STRING&lt;/span&gt; &lt;span class="n"&gt;text_out&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                        &lt;span class="c1"&gt;//存储识别出的字符&lt;/span&gt;

        &lt;span class="n"&gt;TessBaseAPI&lt;/span&gt;  &lt;span class="n"&gt;api&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;IMAGE&lt;/span&gt; &lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="n"&gt;api&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SimpleInit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;/usr/share/tesseract-ocr/tessdata/&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kc"&gt;false&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 初始化函数，tesseract还提供其他的初始化函数 参考 baseapi.h&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read_header&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;read image header error!&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_ysize&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;read image error!&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="c1"&gt;//读取图片并判断是否读取成功&lt;/span&gt;

        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;bytes_per_line&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;check_legal_image_size&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_xsize&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_ysize&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_bpp&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;

        &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;api&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;TesseractRect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_buffer&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_bpp&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;bytes_per_line&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_xsize&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_ysize&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
        &lt;span class="c1"&gt;//tesseract核心api，通过该函数识别出图片中的字符&lt;/span&gt;

        &lt;span class="n"&gt;text_out&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;output: %s&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="n"&gt;FILE&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;fout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fopen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;txt_file&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;w&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="n"&gt;fwrite&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;text_out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;text_out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;fout&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="n"&gt;fclose&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fout&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;5.编译并运行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新建Makefile如下所示。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="go"&gt;LDFLAGS= -ltesseract_full -ltesseract_pageseg -ltesseract_training -ltesseract_textord -ltesseract_wordrec -ltesseract_classify -ltesseract_dict -ltesseract_ccstruct -ltesseract_cutil -ltesseract_viewer -ltesseract_ccutil -ltesseract_image -ltesseract_main -llept -ltiff -ltiffxx -lpthread -lpng -lpng12&lt;/span&gt;

&lt;span class="go"&gt;INCLUDES= -I/usr/include/tesseract/ -I/usr/include/leptonica/&lt;/span&gt;

&lt;span class="go"&gt;all:ocr&lt;/span&gt;

&lt;span class="go"&gt;ocr:&lt;/span&gt;
&lt;span class="go"&gt;        g++ -g -o ocr ocr_test.cpp $(LDFLAGS) $(INCLUDES)&lt;/span&gt;

&lt;span class="go"&gt;clean:&lt;/span&gt;
&lt;span class="go"&gt;        rm ocr&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用下面的命令运行样例程序:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;make
&lt;span class="gp"&gt;$&lt;/span&gt;ocr photo.tif 1.txt
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The End!!&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">hyhx2008</dc:creator><pubDate>Sat, 01 Dec 2012 16:34:00 +0900</pubDate><guid>tag:hyhx2008.github.com,2012-12-01:tesseract-ocrshi-yong-fang-fa-zong-jie.html</guid><category>ocr Linux</category></item><item><title>让google和百度检索自己的网站</title><link>http://hyhx2008.github.com/rang-googlehe-bai-du-jian-suo-zi-ji-de-wang-zhan.html</link><description>&lt;p&gt;自从建立起github博客也有两个星期了，但是在google上一直搜索不到自己的博客。&lt;/p&gt;
&lt;p&gt;等了这么久google还没有抓取我的博客内容。今天问了马星这个问题，马星又早就把解决办法贴在他的
&lt;a class="reference external" href="http://x-wei.github.com/add-google-custom-search.html"&gt;blog&lt;/a&gt;
上了。。&lt;/p&gt;
&lt;p&gt;其实可以主动向搜索引擎申请检索自己的网站，申请链接如下:&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://www.google.com/addurl/?hl=zh-CN&amp;amp;continue=/addurl"&gt;google: http://www.google.com/addurl/?hl=zh-CN&amp;amp;continue=/addurl&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://www.baidu.com/search/url_submit.html"&gt;baidu: http://www.baidu.com/search/url_submit.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;填写自己的网址即可。&lt;/p&gt;
&lt;p&gt;(问完马星才发现google好像几天前已经检索了我的博客内容。。。)&lt;/p&gt;
&lt;p&gt;马星那那篇
&lt;a class="reference external" href="http://x-wei.github.com/add-google-custom-search.html"&gt;blog&lt;/a&gt;
上还讲了如何添加google自定义搜索，不过要使用bootsrap2主题。。&lt;/p&gt;
&lt;p&gt;我瞎折腾了一会儿，也在左边添加了个畸形的自定义搜索框。。。&lt;/p&gt;
&lt;p&gt;The End！！&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">hyhx2008</dc:creator><pubDate>Sun, 18 Nov 2012 23:58:00 +0900</pubDate><guid>tag:hyhx2008.github.com,2012-11-18:rang-googlehe-bai-du-jian-suo-zi-ji-de-wang-zhan.html</guid><category>google</category><category>baidu</category></item><item><title>VMware虚拟机启动时总提示cann't connect to floopy0的问题</title><link>http://hyhx2008.github.com/vmwarexu-ni-ji-qi-dong-shi-zong-ti-shi-cannt-connect-to-floopy0de-wen-ti.html</link><description>&lt;p&gt;在VMware中装了ubuntu，启动时总提示不能连接到设备floopy0，关也关不掉，很讨厌。&lt;/p&gt;
&lt;p&gt;百度了一下解决办法: 修改虚拟机的.vmx文件。&lt;/p&gt;
&lt;p&gt;1.将floppy0.autodetect这项改为FALSE:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="go"&gt;floppy0.autodetect = &amp;quot;FALSE&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.添加一句:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="go"&gt;floppy0.startConnected = &amp;quot;FALSE&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The End!!&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">hyhx2008</dc:creator><pubDate>Tue, 13 Nov 2012 17:26:00 +0900</pubDate><guid>tag:hyhx2008.github.com,2012-11-13:vmwarexu-ni-ji-qi-dong-shi-zong-ti-shi-cannt-connect-to-floopy0de-wen-ti.html</guid><category>ubuntu</category><category>VMware</category></item><item><title>使用pelican生成github博客</title><link>http://hyhx2008.github.com/shi-yong-pelicansheng-cheng-githubbo-ke.html</link><description>&lt;p&gt;自从马星给我推荐在github上写博客到现在已经好久了，今天我终于算是学会了。
我看人家都是用jekyll生成静态页面的，果然和专业到技术宅差得太多，自己尝试折腾了一天也没弄出什么名堂。
马星觉得自己很菜，我居然比马星还菜。。。。。
在马星的诱惑下，用了这个不知到他从哪找来的工具，说实话倒是挺好用的。&lt;/p&gt;
&lt;p&gt;这里记录一下生成博客的步骤（以下内容大多copy自
&lt;a class="reference external" href="http://x-wei.github.com/pelican_github_blog.html"&gt;马星的blog&lt;/a&gt;
）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.配置git&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;注册github后首先要配置git。可以参考
&lt;a class="reference external" href="https://help.github.com/articles/set-up-git#platform-linux"&gt;github:help:set up git&lt;/a&gt;
。&lt;/p&gt;
&lt;p&gt;设置用户名和邮箱，邮箱为注册github时的邮箱地址。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;git config --global user.name &lt;span class="s2"&gt;&amp;quot;hy&amp;quot;&lt;/span&gt;

&lt;span class="gp"&gt;$&lt;/span&gt;git config --global user.email &lt;span class="s2"&gt;&amp;quot;hyxxxxxx@163.com&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以用下面的命令查看配置。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;git config -l
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;github上说可以用https方法提交工程，但是没有成功过，所以还是需要利用ssh。这里需要生成ssh keys，
具体步骤参考
&lt;a class="reference external" href="https://help.github.com/articles/generating-ssh-keys#platform-linux"&gt;github:help:generating ssh keys&lt;/a&gt;
。&lt;/p&gt;
&lt;p&gt;然后就可以进行git clone 和 git push等操作了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.生成github page&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;需要在github上新建一个仓库(repository)，这个仓库的名称必须为
&lt;strong&gt;your_id.github.com&lt;/strong&gt;
。然后将一个index.html文件上传到master分支后，就可以访问域名your_id.github.com看到自己的主页了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.安装和使用pelican&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;pelican安装需要用到python-pip:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;sudo aptitude install python-pip
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后再用pip安装python:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;sudo pip install pelican
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样pelican就安装完成了。&lt;/p&gt;
&lt;p&gt;pelican的使用也很简单, 需要在仓库根目录下新建一个配置文件settings.py, 内容大概如下所示:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;

&lt;span class="n"&gt;TIMEZONE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Asia/Tokyo&amp;#39;&lt;/span&gt;

&lt;span class="n"&gt;DEFAULT_LANG&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;zhs&amp;#39;&lt;/span&gt;

&lt;span class="n"&gt;SITENAME&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;H.y&amp;#39;s Blog&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;AUTHOR&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;hyhx2008&amp;#39;&lt;/span&gt;

&lt;span class="n"&gt;DISQUS_SITENAME&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;hysblog&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;GITHUB_URL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;https://github.com/hyhx2008&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;SITEURL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;http://hyhx2008.github.com&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;GOOGLE_ANALYTICS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;UA-36075477-1&amp;#39;&lt;/span&gt;
&lt;span class="c"&gt;#TAG_FEED_ATOM = &amp;#39;feeds/%s.atom.xml&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;TAG_CLOUD_STEPS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;
&lt;span class="n"&gt;FEED_RSS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;feeds/all.rss.xml&amp;#39;&lt;/span&gt;
&lt;span class="c"&gt;#DEFAULT_ORPHANS=3&lt;/span&gt;
&lt;span class="n"&gt;DEFAULT_PAGINATION&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;
&lt;span class="n"&gt;DELETE_OUTPUT_DIRECTORY&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;
&lt;span class="n"&gt;DEFAULT_CATEGORY&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;tech&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;OUTPUT_PATH&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;.&amp;#39;&lt;/span&gt;

&lt;span class="n"&gt;PATH&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;posts&amp;#39;&lt;/span&gt;

&lt;span class="n"&gt;THEME&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;./pelican-themes/bootstrap&amp;#39;&lt;/span&gt;


&lt;span class="n"&gt;LINKS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;x-wei&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;http://x-wei.github.com&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;farseerfc&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;http://farseerfc.github.com/&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
                          &lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;SOCIAL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;github&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;https://github.com/hyhx2008&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
                            &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;各项的含义可以参见
&lt;a class="reference external" href="https://pelican.readthedocs.org/en/2.8/settings.html"&gt;pelican:settings&lt;/a&gt;
。&lt;/p&gt;
&lt;p&gt;settings.py中有一项PAHT=`posts`, 指的是放置reST格式文件的目录，所以新建一个posts文件夹，然后将博客用
&lt;a class="reference external" href="http://docutils.sourceforge.net/rst.html"&gt;reST&lt;/a&gt;
格式写好之后放在posts文件夹下，即可用pelican生成静态页面了。在仓库根目录下用:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;pelican -s settings.py
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后就可以看到生成的index.html了。&lt;/p&gt;
&lt;p&gt;pelican还可以使用现成的模版，主题可以在github上下载:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;git clone https://github.com/farseerfc/pelican-themes
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;settings.py中的THEME项用来指定要使用的主题模版。&lt;/p&gt;
&lt;p&gt;如果和我一样觉得麻烦的话，可以在github上clone一个现成的博客修改学习，比如:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;git clone git@github.com:hyhx2008/hyhx2008.github.com.git
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;4.将博客上传到github&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用以下三条命令:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;git add .
&lt;span class="gp"&gt;$&lt;/span&gt;git commit -a -m &lt;span class="s2"&gt;&amp;quot;commit message&amp;quot;&lt;/span&gt;
&lt;span class="gp"&gt;$&lt;/span&gt;git push origin master
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;收到一封页面修改成功的邮件后，就可以到自己的主页 your_id.github.com 查看了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.关于reST格式文件的编辑&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;pelican支持markdown和reST两种格式，由于reST的语法高亮比较容易，马星推荐我使用这个格式。附上两个教程:
&lt;a class="reference external" href="https://beinggeekbook.readthedocs.org/en/latest/rst.html"&gt;中文教程&lt;/a&gt;
,
&lt;a class="reference external" href="http://docutils.sourceforge.net/rst.html"&gt;官方英文教程&lt;/a&gt;
。&lt;/p&gt;
&lt;p&gt;在linux环境下可以使用具有实时预览功能的ReText编辑器编辑reST文件，但是后来发现vim中支持reST文件的语法高亮，写起来也挺方便的。&lt;/p&gt;
&lt;p&gt;The End!&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">hyhx2008</dc:creator><pubDate>Sun, 11 Nov 2012 22:20:00 +0900</pubDate><guid>tag:hyhx2008.github.com,2012-11-11:shi-yong-pelicansheng-cheng-githubbo-ke.html</guid><category>GitHub</category><category>pelican</category></item><item><title>重新安装ubuntu后的todo list</title><link>http://hyhx2008.github.com/ubuntu_reinstall_todo-zh.html</link><description>&lt;p&gt;经常把虚拟机里ubuntu搞坏，重装后总记不清还要做什么设置，安什么软件。&lt;/p&gt;
&lt;p&gt;写在这里做个提醒吧，以后再慢慢添加。&lt;/p&gt;
&lt;p&gt;1.安装aptitude&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;sudo apt-get install aptitude
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.安装vim&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;sudo aptitude install vim
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;并修改/usr/share/vim/vimrc 。&lt;/p&gt;
&lt;p&gt;3.添加sudoers&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;sudo visudo
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;加入 hy ALL = （ALL）ALL。&lt;/p&gt;
&lt;p&gt;ubuntu下好像这样做后还是不能使用su命令切换到root，百度解决办法:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;sudo passwd
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改一下密码就好了。&lt;/p&gt;
&lt;p&gt;4.安装openssh&lt;/p&gt;
&lt;p&gt;为了能让secureCRT连上虚拟机里的ubuntu，需要安装openssh。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;sudo aptitude install openssh-server openssh-client
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再用ifconfig查一下ip，填到secureCRT里就好了。&lt;/p&gt;
&lt;p&gt;5.安装中文输入法&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;sudo aptitude install ibus ibus-pinyin ibus-gtk ibus-qt4
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;暂时想到这么多。。。。&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">hyhx2008</dc:creator><pubDate>Sun, 11 Nov 2012 21:44:00 +0900</pubDate><guid>tag:hyhx2008.github.com,2012-11-11:ubuntu_reinstall_todo-zh.html</guid><category>ubuntu</category></item><item><title>Hello World!</title><link>http://hyhx2008.github.com/hello-world.html</link><description>&lt;p&gt;终于建立起了我的github博客~!&lt;/p&gt;
&lt;p&gt;感谢马星手把手一步一步教我如何在github上写博客。&lt;/p&gt;
&lt;p&gt;说是博客，其实估计也没人看，就当做记笔记写总结到好地方了。&lt;/p&gt;
&lt;p&gt;以前都是用evernote写笔记的，但是在粘代码的时候不能语法高亮，所以听了马星的推荐在github上写博客，也算是赶个时髦吧～&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">hyhx2008</dc:creator><pubDate>Sun, 11 Nov 2012 02:16:00 +0900</pubDate><guid>tag:hyhx2008.github.com,2012-11-11:hello-world.html</guid><category>GitHub</category></item><item><title>Festival tts 使用总结</title><link>http://hyhx2008.github.com/festival-tts-shi-yong-zong-jie.html</link><description>&lt;p&gt;&lt;a class="reference external" href="http://www.cstr.ed.ac.uk/projects/festival/"&gt;Festival-tts&lt;/a&gt;
是一个免费的tts (text to speech) 工具，可以将字符串转为声音播放出来或者存为声音文件。&lt;/p&gt;
&lt;p&gt;首先安装:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;sodu aptitude install festival
&lt;span class="gp"&gt;$&lt;/span&gt;sudo aptitude install festival-dev
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以用下面的命令测试一下:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;&lt;span class="nb"&gt;echo &lt;/span&gt;hellow world | festival --tts
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时可以听到喇叭中念出hello world，如果没有声音可能是声卡驱动的问题。&lt;/p&gt;
&lt;p&gt;如果想在自己的程序中使用festival tts的功能，则需要用到festival提供的API，可以参考festiva的文档:
&lt;a class="reference external" href="http://www.cstr.ed.ac.uk/projects/festival/manual/festival_28.html#SEC126"&gt;festival:API&lt;/a&gt;
。&lt;/p&gt;
&lt;p&gt;这里以C++的API为例，介绍两个常用的函数。&lt;/p&gt;
&lt;p&gt;首先程序需要include一个头文件:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;festival.h&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;两个常用API为:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;festival_initialize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;load_init_files&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;heap_size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="n"&gt;festival_say_text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从函数名就可以看出这两个API的作用，第一个为初始化函数，需要在使用其他API之前调用，第二个函数即将text转为声音播放出来。&lt;/p&gt;
&lt;p&gt;下面给出一个样例程序，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;festival/festival.h&amp;gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;

        &lt;span class="c1"&gt;//EST_Wave wave;&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;heap_size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;210000&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// default scheme heap size&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;load_init_files&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// we want the festival init files loaded&lt;/span&gt;

        &lt;span class="n"&gt;festival_initialize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;load_init_files&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;heap_size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="c1"&gt;// Say simple file&lt;/span&gt;
        &lt;span class="c1"&gt;//festival_say_file(&amp;quot;/etc/motd&amp;quot;);&lt;/span&gt;

        &lt;span class="c1"&gt;//festival_eval_command(&amp;quot;(voice_ked_diphone)&amp;quot;);&lt;/span&gt;

        &lt;span class="c1"&gt;// Say some text;&lt;/span&gt;
        &lt;span class="n"&gt;festival_say_text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;hello world&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="c1"&gt;// Convert to a waveform&lt;/span&gt;
        &lt;span class="c1"&gt;//festival_text_to_wave(&amp;quot;hello world&amp;quot;,wave);&lt;/span&gt;

        &lt;span class="c1"&gt;//wave.save(&amp;quot;/tmp/wave.wav&amp;quot;,&amp;quot;riff&amp;quot;);&lt;/span&gt;
        &lt;span class="c1"&gt;// festival_say_file puts the system in async mode so we better&lt;/span&gt;
        &lt;span class="c1"&gt;// wait for the spooler to reach the last waveform before exiting&lt;/span&gt;
        &lt;span class="c1"&gt;// This isn&amp;#39;t necessary if only festival_say_text is being used (and your own wave playing stuff)&lt;/span&gt;

        &lt;span class="c1"&gt;//festival_wait_for_spooler();&lt;/span&gt;

        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其他一些可用的API被我注释掉了，感兴趣的话可以尝试一下。&lt;/p&gt;
&lt;p&gt;程序很简单，麻烦的是编译，需要include很多头文件并连接一大堆库，搞了半天才可以编译通过，下面的编译命令供参考:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="go"&gt;g++ festival_src.cpp -o festival_app -lpthread -lFestival -I/usr/include/festival -I/usr/include/speech_tools -L/usr/lib/speech_tools/lib -lestools -lestbase -leststring&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The End!!&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">hyhx2008</dc:creator><pubDate>Fri, 24 Aug 2012 22:00:00 +0900</pubDate><guid>tag:hyhx2008.github.com,2012-08-24:festival-tts-shi-yong-zong-jie.html</guid><category>festival</category></item><item><title>trace-cmd与kernelshark使用总结</title><link>http://hyhx2008.github.com/trace-cmdyu-kernelsharkshi-yong-zong-jie.html</link><description>&lt;p&gt;&lt;strong&gt;1.trace-cmd&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;trace-cmd是对ftrace的封装，是一个可以用来跟踪linux内核中事件(event)发生的时间、次数等的工具。&lt;/p&gt;
&lt;p&gt;首先需要安装trace-cmd:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;sudo aptitude install trace-cmd
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用也非常简单:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;sudo trace-cmd record -e sched_switch
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;-e 参数指出需要跟踪的事件，这里的sched_switch指的是进程切换，还可以是hrtimer、irq等，例如:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;sudo trace-cmd record -e sched_switch -e hrtimer*
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;命令输完回车后，trace-cmd就开始记录内核中事件的发生了，ctrl+C 停止跟踪，此时会生成一个trace.dat文件，相当于一个log吧。&lt;/p&gt;
&lt;p&gt;trace.dat里的内容不易读，trace-cmd提供分析trace.dat的功能:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;trace-cmd report
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;就可以看到所跟踪的事件发生的情况了，和下图差不多。&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="../statics/pics/trace_cmd_kernelshark1.png" src="../statics/pics/trace_cmd_kernelshark1.png" /&gt;
&lt;/div&gt;
&lt;p&gt;也可以重定向到一个文本文件中再做分析，比如:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;trace-cmd report &amp;gt; report.txt
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;跟踪的报告就存入report.txt中了，可以用Perl等来处理。&lt;/p&gt;
&lt;p&gt;注:使用trace-cmd需要内核开启ftrace，即在编译内核make menuconfig时，选择下面的选项:&lt;/p&gt;
&lt;p&gt;Kernel Hacking -&amp;gt; Tracers -&amp;gt; Kernel Function Tracer&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.kernelshark&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;kernelshark提供了对trace.dat的可视化分析，首先安装:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;sudo aptitude install kernelshark
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后在trace.dat所在的目录输入:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;kernelshark
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;即可看到图形化界面了:&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="../statics/pics/trace_cmd_kernelshark2.png" src="../statics/pics/trace_cmd_kernelshark2.png" /&gt;
&lt;/div&gt;
&lt;p&gt;The End!!&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">hyhx2008</dc:creator><pubDate>Sun, 22 Jul 2012 22:00:00 +0900</pubDate><guid>tag:hyhx2008.github.com,2012-07-22:trace-cmdyu-kernelsharkshi-yong-zong-jie.html</guid><category>trace-cmd</category><category>kernelshark</category></item><item><title>Linux内核编译步骤</title><link>http://hyhx2008.github.com/linuxnei-he-bian-yi-bu-zou.html</link><description>&lt;p&gt;实习的时候需要用到3.0.35-rt56版本的linux内核，这里总结一下Debian下Linux内核编译的步骤, ubuntu下可能略有不同。&lt;/p&gt;
&lt;p&gt;首先进入到内核源码的目录，然后按照以下步骤编译:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.配置内核&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;make menuconfig
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这条命令可以在一个GUI下设置用户需要的内核参数，并生成编译需要的.config配置文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.编译内核&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;make -j 2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;后面的-j参数指的是可以允许多少个module同时编译，-j 2 就是允许2个module同时编译，也可以省略-j参数。如果CPU是多核的话，可以加上该参数提高编译速度。&lt;/p&gt;
&lt;p&gt;接下来就是漫长的等待。。。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.加入模块&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;sudo make modules_install
&lt;span class="gp"&gt;$&lt;/span&gt;sudo make install
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;4.更新引导文件&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;sudo update-initramfs -c -k &lt;span class="s2"&gt;&amp;quot;kernel version&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的kernel version可以在make menuconfig的时候自己设置名称，具体应该写什么需要在/boot文件夹下查看:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;ls -lF /boot
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;比如内核版本为2.6.36，则/boot下就会有一个vmlinuz-2.6.36文件，把vmlinuz-后面的字符放在kernel version的位置即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.更新grub&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;sudo update-grub
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;整个编译过程大概也得一两个小时左右吧，耐心等待。&lt;/p&gt;
&lt;p&gt;The End！！&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">hyhx2008</dc:creator><pubDate>Wed, 18 Jul 2012 22:00:00 +0900</pubDate><guid>tag:hyhx2008.github.com,2012-07-18:linuxnei-he-bian-yi-bu-zou.html</guid><category>linux</category><category>kernel</category><category>compile</category></item></channel></rss>