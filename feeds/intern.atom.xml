<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>H.y's Blog</title><link href="http://hyhx2008.github.com/" rel="alternate"></link><link href="http://hyhx2008.github.com/feeds/intern.atom.xml" rel="self"></link><id>http://hyhx2008.github.com/</id><updated>2012-12-01T16:34:00+09:00</updated><entry><title>tesseract-ocr使用方法总结</title><link href="http://hyhx2008.github.com/tesseract-ocrshi-yong-fang-fa-zong-jie.html" rel="alternate"></link><updated>2012-12-01T16:34:00+09:00</updated><author><name>hyhx2008</name></author><id>tag:hyhx2008.github.com,2012-12-01:tesseract-ocrshi-yong-fang-fa-zong-jie.html</id><summary type="html">&lt;p&gt;实习的时候接触到了一个挺不错的OCR(光学字符识别)工具tesseract，这里总结一下linux下tesseract的简单用法。&lt;/p&gt;
&lt;p&gt;tesseract-ocr是由google维护的一个开源ocr库，可以识别多种格式图片中的文字，可以直接作为一个工具使用，也可以利用tesseract提供的api在自己的程序中使用ocr功能。&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://code.google.com/p/tesseract-ocr/"&gt;项目主页&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.tesseract-ocr安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ubuntu和debian下tesseract的安装非常简单，但是需要安装的包比较多:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;sudo aptitude install tesseract-ocr tesseract-ocr-dev tesseract-ocr-eng
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;tesseract-ocr即为ocr库，tesseract-ocr-dev是使用api时需要用到的头文件。&lt;/p&gt;
&lt;p&gt;tesseract-ocr-eng是语言包，这里安装的是英文，如果要识别其他语言，需要安装其他语言包。&lt;/p&gt;
&lt;p&gt;（语言包安装的位置在/usr/share/tesseract-ocr/tessdata/，该位置将作为初始化api的一个参数）&lt;/p&gt;
&lt;p&gt;为了识别tiff格式的图片，最好再安装以下两个库:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;sudo aptitude install leptonica libtiff
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样tesseract-ocr和一些相关的包就安装完成了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.tesseract-ocr使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作为一个命令行程序，tesseract可以用以下命令识别一张图片中的文字:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="go"&gt;tesseract photo.tif 1.txt&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上命令将从photo.tif中识别的文字存储在1.txt中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.tesseract api 使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;tesseract现在已经出到3.0.1版本了，网上的资料也大多基于3.0.1版本，比如
&lt;a class="reference external" href="http://www.cnblogs.com/zsb517/archive/2012/06/06/2537540.html"&gt;Tesseract3.01在VS2008下面的使用&lt;/a&gt; 和
&lt;a class="reference external" href="http://blog.csdn.net/foxwit/article/details/6547465"&gt;OCR识别引擎tesseract使用方法&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;不幸的是，Debian下安装的是2.0.4版本，api的命名与用法和新版本有所不同。在项目主页上我也没有找到api的使用手册之类的东西，只能自己琢磨。&lt;/p&gt;
&lt;p&gt;我发现查看tesseract的source code是一个很好的学习api用法的途径，源码可以在下面的链接中下载:
&lt;a class="reference external" href="http://code.google.com/p/tesseract-ocr/downloads/detail?name=tesseract-2.04.tar.gz&amp;amp;can=2&amp;amp;q="&gt;tesseract 2.0.4 Source&lt;/a&gt;
，
&lt;a class="reference external" href="http://code.google.com/p/tesseract-ocr/downloads/detail?name=tesseract-3.01.tar.gz&amp;amp;can=2&amp;amp;q="&gt;tesseract 3.0.1 Source&lt;/a&gt;
。&lt;/p&gt;
&lt;p&gt;下载并解压后在ccmain文件夹中的
&lt;strong&gt;tesseractmain.cpp&lt;/strong&gt;
就是tesseract工具的主程序，是很好的api用法参考。api的声明在
&lt;strong&gt;baseapi.h&lt;/strong&gt;
中(ccmain中或/usr/include下都可以找到)。&lt;/p&gt;
&lt;p&gt;所有需要include的头文件都在 /usr/include/tesseract 和 /usr/include/lptonica 中，需要链接的库在/usr/lib中。&lt;/p&gt;
&lt;p&gt;api的具体用法参见后面附的源码的注释。&lt;/p&gt;
&lt;p&gt;编译真的是最痛苦的事情，不清楚需要链接哪些库，于是/usr/lib里用下面的命令找到相关的库，全都链接进来:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;ls | grep tesseract
&lt;span class="gp"&gt;$&lt;/span&gt;ls | grep leptonica
&lt;span class="gp"&gt;$&lt;/span&gt;ls | grep tiff
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果编译还是不通过，提示一大堆未定义的函数，发现都和png有关系，于是又用&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;ls | grep png
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;找到一个库链接后才编译成功。我编译用的Makefile附在最后。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.api使用的例子&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新建一个ocr_test.cpp文件，将下面的代码粘贴进去即可。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;mfcpch.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;ctype.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;applybox.h&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;control.h&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;tessvars.h&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;tessedit.h&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;baseapi.h&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;pageres.h&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;imgs.h&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;varabled.h&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;tprintf.h&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;stderr.h&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;notdll.h&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;mainblk.h&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;output.h&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;globals.h&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;blread.h&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;tfacep.h&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;callnet.h&amp;quot;&lt;/span&gt;


&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;usage:%s &amp;lt;tiff file&amp;gt; &amp;lt;txt file&amp;gt;/n&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
                &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;image_file&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;       &lt;span class="c1"&gt;//程序的第一个参数为图片路径&lt;/span&gt;
        &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;txt_file&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;         &lt;span class="c1"&gt;//第二个参数为保存识别出的字符的文件路径&lt;/span&gt;

        &lt;span class="n"&gt;STRING&lt;/span&gt; &lt;span class="n"&gt;text_out&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                        &lt;span class="c1"&gt;//存储识别出的字符&lt;/span&gt;

        &lt;span class="n"&gt;TessBaseAPI&lt;/span&gt;  &lt;span class="n"&gt;api&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;IMAGE&lt;/span&gt; &lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="n"&gt;api&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SimpleInit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;/usr/share/tesseract-ocr/tessdata/&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// 初始化函数，tesseract还提供其他的初始化函数 参考 baseapi.h&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read_header&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;read image header error!&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_ysize&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;read image error!&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="c1"&gt;//读取图片并判断是否读取成功&lt;/span&gt;

        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;bytes_per_line&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;check_legal_image_size&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_xsize&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_ysize&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_bpp&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;

        &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;api&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;TesseractRect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_buffer&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_bpp&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;bytes_per_line&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_xsize&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_ysize&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
        &lt;span class="c1"&gt;//tesseract核心api，通过该函数识别出图片中的字符&lt;/span&gt;

        &lt;span class="n"&gt;text_out&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;output: %s&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="kt"&gt;FILE&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;fout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fopen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;txt_file&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;w&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="n"&gt;fwrite&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;text_out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;text_out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;fout&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="n"&gt;fclose&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fout&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;5.编译并运行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新建Makefile如下所示。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="go"&gt;LDFLAGS= -ltesseract_full -ltesseract_pageseg -ltesseract_training -ltesseract_textord -ltesseract_wordrec -ltesseract_classify -ltesseract_dict -ltesseract_ccstruct -ltesseract_cutil -ltesseract_viewer -ltesseract_ccutil -ltesseract_image -ltesseract_main -llept -ltiff -ltiffxx -lpthread -lpng -lpng12&lt;/span&gt;

&lt;span class="go"&gt;INCLUDES= -I/usr/include/tesseract/ -I/usr/include/leptonica/&lt;/span&gt;

&lt;span class="go"&gt;all:ocr&lt;/span&gt;

&lt;span class="go"&gt;ocr:&lt;/span&gt;
&lt;span class="go"&gt;        g++ -g -o ocr ocr_test.cpp $(LDFLAGS) $(INCLUDES)&lt;/span&gt;

&lt;span class="go"&gt;clean:&lt;/span&gt;
&lt;span class="go"&gt;        rm ocr&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用下面的命令运行样例程序:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;make
&lt;span class="gp"&gt;$&lt;/span&gt;ocr photo.tif 1.txt
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The End!!&lt;/p&gt;
</summary><category term="ocr Linux"></category></entry><entry><title>Festival tts 使用总结</title><link href="http://hyhx2008.github.com/festival-tts-shi-yong-zong-jie.html" rel="alternate"></link><updated>2012-08-24T22:00:00+09:00</updated><author><name>hyhx2008</name></author><id>tag:hyhx2008.github.com,2012-08-24:festival-tts-shi-yong-zong-jie.html</id><summary type="html">&lt;p&gt;&lt;a class="reference external" href="http://www.cstr.ed.ac.uk/projects/festival/"&gt;Festival-tts&lt;/a&gt;
是一个免费的tts (text to speech) 工具，可以将字符串转为声音播放出来或者存为声音文件。&lt;/p&gt;
&lt;p&gt;首先安装:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;sodu aptitude install festival
&lt;span class="gp"&gt;$&lt;/span&gt;sudo aptitude install festival-dev
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以用下面的命令测试一下:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;&lt;span class="nb"&gt;echo &lt;/span&gt;hellow world | festival --tts
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时可以听到喇叭中念出hello world，如果没有声音可能是声卡驱动的问题。&lt;/p&gt;
&lt;p&gt;如果想在自己的程序中使用festival tts的功能，则需要用到festival提供的API，可以参考festiva的文档:
&lt;a class="reference external" href="http://www.cstr.ed.ac.uk/projects/festival/manual/festival_28.html#SEC126"&gt;festival:API&lt;/a&gt;
。&lt;/p&gt;
&lt;p&gt;这里以C++的API为例，介绍两个常用的函数。&lt;/p&gt;
&lt;p&gt;首先程序需要include一个头文件:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;festival.h&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;两个常用API为:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;festival_initialize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;load_init_files&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;heap_size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="n"&gt;festival_say_text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从函数名就可以看出这两个API的作用，第一个为初始化函数，需要在使用其他API之前调用，第二个函数即将text转为声音播放出来。&lt;/p&gt;
&lt;p&gt;下面给出一个样例程序，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;festival/festival.h&amp;gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;

        &lt;span class="c1"&gt;//EST_Wave wave;&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;heap_size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;210000&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// default scheme heap size&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;load_init_files&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// we want the festival init files loaded&lt;/span&gt;

        &lt;span class="n"&gt;festival_initialize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;load_init_files&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;heap_size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="c1"&gt;// Say simple file&lt;/span&gt;
        &lt;span class="c1"&gt;//festival_say_file(&amp;quot;/etc/motd&amp;quot;);&lt;/span&gt;

        &lt;span class="c1"&gt;//festival_eval_command(&amp;quot;(voice_ked_diphone)&amp;quot;);&lt;/span&gt;

        &lt;span class="c1"&gt;// Say some text;&lt;/span&gt;
        &lt;span class="n"&gt;festival_say_text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;hello world&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="c1"&gt;// Convert to a waveform&lt;/span&gt;
        &lt;span class="c1"&gt;//festival_text_to_wave(&amp;quot;hello world&amp;quot;,wave);&lt;/span&gt;

        &lt;span class="c1"&gt;//wave.save(&amp;quot;/tmp/wave.wav&amp;quot;,&amp;quot;riff&amp;quot;);&lt;/span&gt;
        &lt;span class="c1"&gt;// festival_say_file puts the system in async mode so we better&lt;/span&gt;
        &lt;span class="c1"&gt;// wait for the spooler to reach the last waveform before exiting&lt;/span&gt;
        &lt;span class="c1"&gt;// This isn&amp;#39;t necessary if only festival_say_text is being used (and your own wave playing stuff)&lt;/span&gt;

        &lt;span class="c1"&gt;//festival_wait_for_spooler();&lt;/span&gt;

        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其他一些可用的API被我注释掉了，感兴趣的话可以尝试一下。&lt;/p&gt;
&lt;p&gt;程序很简单，麻烦的是编译，需要include很多头文件并连接一大堆库，搞了半天才可以编译通过，下面的编译命令供参考:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="go"&gt;g++ festival_src.cpp -o festival_app -lpthread -lFestival -I/usr/include/festival -I/usr/include/speech_tools -L/usr/lib/speech_tools/lib -lestools -lestbase -leststring&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The End!!&lt;/p&gt;
</summary><category term="festival"></category></entry><entry><title>trace-cmd与kernelshark使用总结</title><link href="http://hyhx2008.github.com/trace-cmdyu-kernelsharkshi-yong-zong-jie.html" rel="alternate"></link><updated>2012-07-22T22:00:00+09:00</updated><author><name>hyhx2008</name></author><id>tag:hyhx2008.github.com,2012-07-22:trace-cmdyu-kernelsharkshi-yong-zong-jie.html</id><summary type="html">&lt;p&gt;&lt;strong&gt;1.trace-cmd&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;trace-cmd是对ftrace的封装，是一个可以用来跟踪linux内核中事件(event)发生的时间、次数等的工具。&lt;/p&gt;
&lt;p&gt;首先需要安装trace-cmd:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;sudo aptitude install trace-cmd
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用也非常简单:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;sudo trace-cmd record -e sched_switch
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;-e 参数指出需要跟踪的事件，这里的sched_switch指的是进程切换，还可以是hrtimer、irq等，例如:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;sudo trace-cmd record -e sched_switch -e hrtimer*
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;命令输完回车后，trace-cmd就开始记录内核中事件的发生了，ctrl+C 停止跟踪，此时会生成一个trace.dat文件，相当于一个log吧。&lt;/p&gt;
&lt;p&gt;trace.dat里的内容不易读，trace-cmd提供分析trace.dat的功能:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;trace-cmd report
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;就可以看到所跟踪的事件发生的情况了，和下图差不多。&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="../statics/pics/trace_cmd_kernelshark1.png" src="../statics/pics/trace_cmd_kernelshark1.png" /&gt;
&lt;/div&gt;
&lt;p&gt;也可以重定向到一个文本文件中再做分析，比如:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;trace-cmd report &amp;gt; report.txt
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;跟踪的报告就存入report.txt中了，可以用Perl等来处理。&lt;/p&gt;
&lt;p&gt;注:使用trace-cmd需要内核开启ftrace，即在编译内核make menuconfig时，选择下面的选项:&lt;/p&gt;
&lt;p&gt;Kernel Hacking -&amp;gt; Tracers -&amp;gt; Kernel Function Tracer&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.kernelshark&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;kernelshark提供了对trace.dat的可视化分析，首先安装:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;sudo aptitude install kernelshark
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后在trace.dat所在的目录输入:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;kernelshark
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;即可看到图形化界面了:&lt;/p&gt;
&lt;div class="figure"&gt;
&lt;img alt="../statics/pics/trace_cmd_kernelshark2.png" src="../statics/pics/trace_cmd_kernelshark2.png" /&gt;
&lt;/div&gt;
&lt;p&gt;The End!!&lt;/p&gt;
</summary><category term="trace-cmd"></category><category term="kernelshark"></category></entry><entry><title>Linux内核编译步骤</title><link href="http://hyhx2008.github.com/linuxnei-he-bian-yi-bu-zou.html" rel="alternate"></link><updated>2012-07-18T22:00:00+09:00</updated><author><name>hyhx2008</name></author><id>tag:hyhx2008.github.com,2012-07-18:linuxnei-he-bian-yi-bu-zou.html</id><summary type="html">&lt;p&gt;实习的时候需要用到3.0.35-rt56版本的linux内核，这里总结一下Debian下Linux内核编译的步骤, ubuntu下可能略有不同。&lt;/p&gt;
&lt;p&gt;首先进入到内核源码的目录，然后按照以下步骤编译:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.配置内核&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;make menuconfig
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这条命令可以在一个GUI下设置用户需要的内核参数，并生成编译需要的.config配置文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.编译内核&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;make -j 2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;后面的-j参数指的是可以允许多少个module同时编译，-j 2 就是允许2个module同时编译，也可以省略-j参数。如果CPU是多核的话，可以加上该参数提高编译速度。&lt;/p&gt;
&lt;p&gt;接下来就是漫长的等待。。。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.加入模块&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;sudo make modules_install
&lt;span class="gp"&gt;$&lt;/span&gt;sudo make install
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;4.更新引导文件&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;sudo update-initramfs -c -k &lt;span class="s2"&gt;&amp;quot;kernel version&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的kernel version可以在make menuconfig的时候自己设置名称，具体应该写什么需要在/boot文件夹下查看:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;ls -lF /boot
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;比如内核版本为2.6.36，则/boot下就会有一个vmlinuz-2.6.36文件，把vmlinuz-后面的字符放在kernel version的位置即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.更新grub&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;$&lt;/span&gt;sudo update-grub
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;整个编译过程大概也得一两个小时左右吧，耐心等待。&lt;/p&gt;
&lt;p&gt;The End！！&lt;/p&gt;
</summary><category term="linux"></category><category term="kernel"></category><category term="compile"></category></entry></feed>