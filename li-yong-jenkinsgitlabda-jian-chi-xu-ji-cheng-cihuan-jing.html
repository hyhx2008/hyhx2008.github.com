<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>H.y's Blog</title>
	<meta name="description" content="">
	<meta name="author" content="hyhx2008">

	<!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
	<!--[if lt IE 9]>
		<script src="http://hyhx2008.github.com/theme/html5.js"></script>
	<![endif]-->

	<!-- Le styles -->
	<link href="http://hyhx2008.github.com/theme/bootstrap.min.css" rel="stylesheet">
	<link href="http://hyhx2008.github.com/theme/local.css" rel="stylesheet">
	<link href="http://hyhx2008.github.com/theme/pygments.css" rel="stylesheet">
	<script>var _gaq=[['_setAccount','UA-36075477-1'],['_trackPageview']];(function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];g.src='//www.google-analytics.com/ga.js';s.parentNode.insertBefore(g,s)}(document,'script'))</script>
	<script type="text/javascript">
	var disqus_identifier = "li-yong-jenkinsgitlabda-jian-chi-xu-ji-cheng-cihuan-jing.html";
	(function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = 'http://hysblog.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	})();
</script>
		
	<link rel="shortcut icon" href="http://hyhx2008.github.com/theme/images/icons/icon1.png">
</head>
<body>
		<a href="https://github.com/hyhx2008"><img style="position: absolute; top: 39px; right: 0; border: 0;" src="http://s3.amazonaws.com/github/ribbons/forkme_right_white_ffffff.png" alt="Fork me on GitHub" /></a>
	<div class="topbar">
	  <div class="topbar-inner">
		<div class="container-fluid">
		  <a class="brand" href="http://hyhx2008.github.com/index.html">H.y's Blog</a>
			<ul class="nav">
																										<li ><a href="http://hyhx2008.github.com/category/clrs.html">clrs</a></li>
									<li class="active"><a href="http://hyhx2008.github.com/category/intern.html">intern</a></li>
									<li ><a href="http://hyhx2008.github.com/category/my.html">my</a></li>
									<li ><a href="http://hyhx2008.github.com/category/peersim.html">peersim</a></li>
									<li ><a href="http://hyhx2008.github.com/category/raspberry-pi.html">raspberry-pi</a></li>
									<li ><a href="http://hyhx2008.github.com/category/tech.html">tech</a></li>
									<li ><a href="http://hyhx2008.github.com/category/ubuntu.html">ubuntu</a></li>
							</ul>
			<p class="pull-right"><a href="http://hyhx2008.github.com/archives.html">[archives]</a> <a href="http://hyhx2008.github.com/tags.html">[tags]</a></p>
		</div>
	  </div>
	</div>

	<div class="container-fluid">	
	  <div class="span5 sidebar">
		<div class="well">
			<h3>Blogroll</h3>
			<ul>
								<li><a href="http://x-wei.github.com">x-wei</a></li>
								<li><a href="http://farseerfc.github.com/">farseerfc</a></li>
							</ul>
			<div class="social">
			<h3>Social</h3>
			<ul>
								<li><a href="https://github.com/hyhx2008">github</a></li>
							</ul>
			</div>
			
		</div>
		
		<div class="well">
			<div class="search_sidebar">
				<li class="nav-header"><h4><i class="icon-search"></i>Google Search</h4></li>
<!-- Put the following javascript before the closing </head> tag. -->
<script>
  (function() {
    var cx = '007947589229995882978:padodsakamc';
    var gcse = document.createElement('script'); gcse.type = 'text/javascript'; gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//www.google.com/cse/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(gcse, s);
  })();
</script>
<!-- Place this tag where you want both of the search box and the search results to render -->
<gcse:search></gcse:search>
			</div>

			<div class="google_ads">
				<li class="nav-header"><h4><i class="icon-search"></i>Google Ads</h4></li>
<script type="text/javascript"><!--
google_ad_client = "ca-pub-5617943900713834";
/* HY&#39;s github blog */
google_ad_slot = "7280262031";
google_ad_width = 160;
google_ad_height = 600;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
			</div>
		</div>

	  </div>
	  <div class="content">
							<div class='article'>
		<div class="page-header"><h1>利用Jenkins+Gitlab搭建持续集成(CI)环境</h1></div>
		<div class="well small">Permalink: <a class="more" href="http://hyhx2008.github.com/li-yong-jenkinsgitlabda-jian-chi-xu-ji-cheng-cihuan-jing.html">2013-09-08 22:04:00</a>
by <a class="url fn" href="http://hyhx2008.github.com/author/hyhx2008.html">hyhx2008</a>in <a href="http://hyhx2008.github.com/category/intern.html">intern</a>
tags: <a href="http://hyhx2008.github.com/tag/jenkins.html">jenkins</a> <a href="http://hyhx2008.github.com/tag/gitlab.html">gitlab</a> <a href="http://hyhx2008.github.com/tag/distcc.html">distcc</a> <a href="http://hyhx2008.github.com/tag/ci.html">ci</a> </div>
		<div><p>这次实习的任务之一就是搭建一个持续集成(Continuous Integration)环境。</p>
<p>我们选择Jenkins作为持续集成工具，其优点是提供web GUI配置界面，方便配置，还可以安装很多第三方插件（plugin）进行定制与扩展，功能强大。</p>
<p>其次选择Gitlab作为git server。Gitlab的功能和Github差不多，但是是开源的，可以用来搭建私有git server，也提供非常强大的web GUI，比如开发者互相review源代码的时候就会很方便。</p>
<p>本文首先介绍整个系统的结构，然后再一一叙述各个组件的安装及使用方法。</p>
<p><strong>1.系统概览</strong></p>
<p>系统结构如下图所示:</p>
<div class="figure">
<img alt="figure_1" src="../statics/pics/ci_1.png" />
</div>
<p>系统的工作流程大概分为以下几步:</p>
<p>1&gt; 开发者将新版本push到git server (Gitlab)。</p>
<p>2&gt; Gitlab随后触发jenkins master结点进行一次build。(通过web hook或者定时检测)</p>
<p>3&gt; jenkins master结点将这个build任务分配给若干个注册的slave结点中的一个，这个slave结点根据一个事先设置好的脚本进行build。这个脚本可以做的事情很多，比如编译，测试，生成测试报告等等。这些原本需要手动完成的任务都可以交给jenkins来做。</p>
<p>4&gt; 我们在build中要进行编译，这里使用了分布式编译器distcc来加快编译速度。</p>
<p><strong>notes</strong></p>
<p>jenkins的工作原理是先将源代码从gitlab中拷贝一份到本地，然后根据设置的脚本进行build。我们可以看出，整个系统的关键就是那个build脚本，用来告诉jenkins在一次集成中需要执行的任务。</p>
<p><strong>2.Jenkins的安装与配置</strong></p>
<p><strong>1&gt; 安装Jenkins</strong></p>
<p>首先说如何安装
<a class="reference external" href="http://jenkins-ci.org/">jenkins</a>
，一定要安装最新版本才不会出各种奇怪的问题，参考官网wiki,
<a class="reference external" href="https://wiki.jenkins-ci.org/display/JENKINS/Installing+Jenkins+on+Ubuntu">Installing Jenkins on Ubuntu</a>
上的指示，</p>
<div class="highlight"><pre><span class="gp">$</span> wget -q -O - http://pkg.jenkins-ci.org/debian/jenkins-ci.org.key | sudo apt-key add -
<span class="gp">$</span> sudo sh -c <span class="s1">&#39;echo deb http://pkg.jenkins-ci.org/debian binary/ &gt; /etc/apt/sources.list.d/jenkins.list&#39;</span>
<span class="gp">$</span> sudo apt-get update
<span class="gp">$</span> sudo apt-get install jenkins
</pre></div>
<p>即可以得到最新版的jenkins。</p>
<p>Jenkins安装完毕后，可以通过浏览器访问其Dashboard，例如192.168.16.183：8080，IP地址即为Jenkins所在机器的IP地址。</p>
<p><strong>2&gt; Jenkins插件安装</strong></p>
<p>Jenkins其实没有什么需要特别配置的，由于这次任务中需要利用Jenkins与git，gitlab协作，所以需要安装一些插件。在主面板上点击Manage Jenkins -&gt; Manage Plugins。</p>
<p>由于公司使用代理连接外网，首先需要为Jenkins插件安装配置proxy。点击Advanced标签即进入proxy设置页面。</p>
<p>Aailable标签下就是可以安装的插件。</p>
<p>要让Jenkins可以自动build git repo中的代码，需要安装GIT Client Plugin和GIT Plugin。</p>
<p>要想Jenkins可以收到Gitlab发来的hook从而自动build，需要安装 Gitlab Hook Plugin。</p>
<p>要让Jenkins可以在build完成之后根据TAP（test anything protocol）文件生成graph，需要安装 TAP Plugin。</p>
<p><strong>3&gt; Jenkins Job</strong></p>
<p>我们尝试新建一个Jenkins Job，必须填的内容不是很多，而且每一项后面都有意一个问号，点击后会有关于这项的一些提示。</p>
<p>（1）首先是Project name；</p>
<p>（2）然后在Source Code Management 中选择Git，我们只需要提供Repository URL即可，这个URL可以是Jenkins机器上的一个本地repo，例如/home/woody/repo；也可以是一个远程机器上的repo，例如Gitlab上通过ssh连接的repo： <a class="reference external" href="mailto:git&#64;192.168.16.194">git&#64;192.168.16.194</a>:user/test_gitlab_repo.git</p>
<p>注意，我们需要在Jenkins机器上设置Git username 和 email，不然后面会build不成功。</p>
<p>（3）下面需要在Build中选择Add build step，这里以最熟悉的shell为例，选择Execute shell。Jenkins的工作原理很简单，就是从刚才的Repository URL里clone到当前的一个workspace中并切换到最新的branch然后执行Execute shell中的command，如果每条command都返回0则build成功，否则则算失败。 所以我们的shell command可以是简单的编译指令例如：</p>
<div class="highlight"><pre><span class="gp">#</span>!/bin/sh
<span class="go">make</span>
</pre></div>
<p>（这需要你的git repo中有一个makfile）</p>
<p>也可以执行repo中的另一个脚本，例如</p>
<div class="highlight"><pre><span class="gp">#</span>!/bin/sh
<span class="go">perl test.pl</span>
</pre></div>
<p>甚至可以什么都不做，或者是只输入一些字符。</p>
<p>（4）接下来我们需要设置一个触发选项，在Build Triggers中，Jenkins提供三个选择</p>
<p>Build after other projects are built    顾名思义</p>
<p>Build periodically    周期性地build</p>
<p>Poll SCM              周期性的检测SCM（如Git）中是否有新的提交，如果有则build</p>
<p>选择后面两项我们都需要在Schedule中设置周期，点击后面的问号可以查看的设置周期的语法。</p>
<p>到这一步结束后我们就可以Save配置了，可以在面板中点击Build Now看看是否可以正常工作。在下面的Build History中有该Job的所有build历史，点击任意一条进去后可以进行查看，特别说明可以在Console Output中看到执行这次build时控制台的输出信息。</p>
<p>（5）如果安装了TAP Plugin，我们还可以配置Job在build完成后根据TAP result生成一副Graph例如下图：</p>
<div class="figure">
<img alt="figure_2" src="../statics/pics/ci_2.png" />
</div>
<p>这幅图显示了每次build中成功与失败次数的走势。</p>
<p>想要得到这张图的话，需要在Configure的Post-build Action中选择Add post-build action -&gt; Publish TAP result。 然后在test result 中输入你的TAP result文件的路径，例如tap.tap指的就是当前文件下的tap.tap文件。也就是说在你的Execute Shell中，你需要在编译完成后根据结果自己生成一个TAP文件，TAP的语法可以参考Jenkins TAP Plugin的说明。</p>
<p><strong>4&gt; 搭建Jenkins Master - Slaves 架构</strong></p>
<p>我们在配置Jenkins时，有一个# of executors 选项，这项代表了Jenkins可以同时处理的Job的数量。</p>
<p>Jenkins还支持将Job分给Slave处理的功能。这就需要我们为Jenkins配置一些Slaves。</p>
<p>在Dashboard中点击 Mamage Jenkins -&gt; Manage Nodes -&gt; New Node</p>
<p>然后输入Node name 并选择Dumb Slave 点击OK后进入配置页面。需要填的内容如下图所示：</p>
<div class="figure">
<img alt="figure_3" src="../statics/pics/ci_3.png" />
</div>
<p># of executors指的是该slave上允许同时处理的job数量； 其他选项也都顾名思义， 我们这里选择用SSH的方式进行连接，Host即为Slave的IP地址。</p>
<p>Slave上不需要安装Jenkins，只需要安装java环境和git即可：</p>
<div class="highlight"><pre><span class="gp">$</span> sudo aptitude install default-jre
<span class="gp">$</span> sudo aptitude install git
</pre></div>
<p>还需要为slave的jenkins用户配置git user.name &amp; user.email</p>
<p>这里需要说明一个地方，Jenkins在工作时是利用一个名为jenkins的用户登入机器的。</p>
<p>在master节点上，安装Jenkins时自动为系统添加了一个名为jenkins的用户，由于slave机器上不需要安装jenkins，所以我们需要在slave机器上手动添加一个名为jenkins的用户。而且Jenkins master只能通过不用输入密码的SSH方式连接slave，需要在master上用jenkins用户生成一对ssh密钥，并把公钥加入slave机器上jenkins用户的用户目录里.ssh/authorized_keys中。</p>
<p>注意，没有密码的用户在ubuntu下可能切换不成功，我们用下面的方法：</p>
<div class="highlight"><pre><span class="gp">$</span> sudo su jenkins
<span class="gp">$</span> bash
</pre></div>
<p><strong>3.Gitlab的安装与配置</strong></p>
<p>Gitlab的功能和Github差不多，都是作为git server。</p>
<p>Gitlab是开源的，我们可以利用Gitlab搭建自己私有的git server。</p>
<p>我们可以在bitnami上下载
<a class="reference external" href="http://bitnami.com/stack/gitlab">Gitlab</a>
。</p>
<p>公司有现成的Gitlab，所以我没有尝试Gitlab的安装，看上去成功安装并不容易。</p>
<p>为了测试，还是在虚拟机环境下配置了Gitlab，直接下载了Virtual Machine镜像，由于镜像是Vmware的，还需要将其转为Virtual Box镜像，方法参见 <a class="reference external" href="http://wiki.bitnami.com/Virtual_Appliances_Quick_Start_Guide">http://wiki.bitnami.com/Virtual_Appliances_Quick_Start_Guide</a>。</p>
<p>在虚拟机上跑起来后，发现是一个没有GUI的ubuntu。。。系统用户名和密码都是bitnami。</p>
<p>我们还可以通过访问其IP地址登入Gitlab，初始用户名为user，密码为bitnami，看上去和github很象。</p>
<hr class="docutils" />
<p>由于在这次任务中Jenkins需要从Gitlab中获取文件并build，所以我们需要在Gitlab的工程中设置一些东西。</p>
<p>首先是settings -&gt; Deploy Keys, 这里需要加入Jenkins所在机器jenkins用户的公钥。</p>
<p>如果Jenkins中使用slave，还需要将slave的公钥加入deloy keys中。 因为slave的工作原理是收到master的指示直接clone repository。</p>
<p>然后是一个叫Web Hooks的东东。还记得我们在Jenkins中安装过Gitlab Hook Plugin么，如果设置了Web Hooks，Gitlab就会在每次push上来后发送一条消息到指定的地址（即hook的地址），Jenkins Gitlab Hook Plugin收到消息后立即build。</p>
<p>不过我按照Gitlab Hook Plugin的说明设置里hooks后并没有什么作用，可能是那个插件的bug吧。。</p>
<p>后来大哥告诉我一个巧妙的办法，就是将Jenkins Job里的build now连接作为hook地址，例如http://192.168.16.183:8080/job/test_gitlab/build?delay=0sec</p>
<p>这样每次Gitlab收到push后就会促使Jenkins立即build。</p>
<p><strong>4.distcc的安装与配置</strong></p>
<p>distcc是一个分布式的编译器，他可以将编译任务分配给多个其他机器上的destccd-daemon，从而加速编译过程。</p>
<p>1&gt; 安装</p>
<p>ubuntu下distcc很容易安装</p>
<div class="highlight"><pre><span class="gp">$</span> sudo aptitude install distcc
</pre></div>
<p>2&gt; 配置</p>
<p>distcc分为前端和守护进程，前端的用法和gcc差不多，用来编译源代码文件。</p>
<p>守护进程即distcc-daemon，需要一些配置。</p>
<p>守护进程的配置文件在 /etc/default/distcc 中，</p>
<div class="highlight"><pre><span class="gp">$</span> sudo vim /etc/default/distcc

<span class="go">STARTDISTCC=&quot;true&quot;                 //这项允许distccd启动</span>

<span class="go">ALLOWEDNETS=“192.168.16.0/24”  //这项指出里允许那些IP的distcc连接上来， /24指的是子网掩码前24位为1，后面为0，即代表192.168.16.0 ～ 192.168.16.255</span>
<span class="go">LISTENER=“192.168.16.183”      //这项应该填本机的IP地址，即需要监听的IP地址</span>

<span class="go">ZEROCONF = “false”             //这项指出不开启zeroconf，我们先讲不开启zeroconf，后面再讨论使用它的情况</span>
</pre></div>
<p>这样一个distccd就配置完成了。</p>
<p>通过以下命令可以开启和停止distccd</p>
<div class="highlight"><pre><span class="gp">$</span> sudo service distcc start
<span class="gp">$</span> sudo service distcc stop
</pre></div>
<p>在进行编译前，因为distccd都没有开启zeroconf，所以distcc无法知道有哪些host可供使用，所以这里需要在环境变量中加入，例如</p>
<div class="highlight"><pre><span class="go">export DISTCC_HOSTS=&quot;192.168.16.183 192.168.16.198&quot;</span>
</pre></div>
<p>使用下面的命令可以查看hosts是否配置成功。</p>
<div class="highlight"><pre><span class="gp">$</span> distcc --show-hosts
</pre></div>
<p>然后就可以使用distcc进行分布式编译，例如编译linux kernel，</p>
<div class="highlight"><pre><span class="gp">$</span> make <span class="nv">CC</span><span class="o">=</span>distcc
</pre></div>
<hr class="docutils" />
<p>下面讲当我们为distccd开启ZEROCONF时即配置</p>
<div class="highlight"><pre><span class="go">ZEROCONF=“true”</span>
</pre></div>
<p>这就说明distcc可以不需要手动配置hosts地址即可以发现可用的hosts，具体原理不是很清楚，反正用命令</p>
<div class="highlight"><pre><span class="gp">$</span> distcc --show-hosts
</pre></div>
<p>可以看到distccd的地址。</p>
<p>但是这里貌似对IPv6的解析上有一个bug，百度里一下说需要关闭avahi的IPv6</p>
<p>编辑 /etc/avahi/avahi-daemon.conf</p>
<p>修改以下内容</p>
<div class="highlight"><pre><span class="go">use-ipv6=no</span>
</pre></div>
<p>即可。</p>
<p>然后还需要在调用distcc的用户的环境变量中加入</p>
<div class="highlight"><pre><span class="go">export DISTCC_HOSTS=&quot;+zeroconf&quot;</span>
</pre></div>
<hr class="docutils" />
<p>我们还可以在调用distcc的用户中用以下命令查看编译的进度</p>
<div class="highlight"><pre><span class="gp">$</span> distccmom-text 5
</pre></div>
</div>
		<div>
			<h2>Comments</h2>
		 				<div id="disqus_thread"></div>					<div>
	</div>	
		<footer>
		  <p> Powered by <a href="http://alexis.notmyidea.org/pelican/">Pelican</a>, theme based on <a href="http://twitter.github.com/bootstrap/">Bootstrap, from Twitter</a>.</p>
		  <p>&copy; hyhx2008 2011</p>
		</footer>
	  </div>
   
	</div>
</body>
</html>