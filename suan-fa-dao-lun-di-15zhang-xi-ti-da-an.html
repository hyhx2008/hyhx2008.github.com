<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>H.y's Blog</title>
	<meta name="description" content="">
	<meta name="author" content="hyhx2008">

	<!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
	<!--[if lt IE 9]>
		<script src="http://hyhx2008.github.com/theme/html5.js"></script>
	<![endif]-->

	<!-- Le styles -->
	<link href="http://hyhx2008.github.com/theme/bootstrap.min.css" rel="stylesheet">
	<link href="http://hyhx2008.github.com/theme/local.css" rel="stylesheet">
	<link href="http://hyhx2008.github.com/theme/pygments.css" rel="stylesheet">
	<script>var _gaq=[['_setAccount','UA-36075477-1'],['_trackPageview']];(function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];g.src='//www.google-analytics.com/ga.js';s.parentNode.insertBefore(g,s)}(document,'script'))</script>
	<script type="text/javascript">
	var disqus_identifier = "suan-fa-dao-lun-di-15zhang-xi-ti-da-an.html";
	(function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = 'http://hysblog.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	})();
</script>
		
	<link rel="shortcut icon" href="http://hyhx2008.github.com/theme/images/icons/icon1.png">
</head>
<body>
		<a href="https://github.com/hyhx2008"><img style="position: absolute; top: 39px; right: 0; border: 0;" src="http://s3.amazonaws.com/github/ribbons/forkme_right_white_ffffff.png" alt="Fork me on GitHub" /></a>
	<div class="topbar">
	  <div class="topbar-inner">
		<div class="container-fluid">
		  <a class="brand" href="http://hyhx2008.github.com/index.html">H.y's Blog</a>
			<ul class="nav">
																										<li class="active"><a href="http://hyhx2008.github.com/category/clrs.html">clrs</a></li>
									<li ><a href="http://hyhx2008.github.com/category/intern.html">intern</a></li>
									<li ><a href="http://hyhx2008.github.com/category/my.html">my</a></li>
									<li ><a href="http://hyhx2008.github.com/category/peersim.html">peersim</a></li>
									<li ><a href="http://hyhx2008.github.com/category/tech.html">tech</a></li>
									<li ><a href="http://hyhx2008.github.com/category/ubuntu.html">ubuntu</a></li>
							</ul>
			<p class="pull-right"><a href="http://hyhx2008.github.com/archives.html">[archives]</a> <a href="http://hyhx2008.github.com/tags.html">[tags]</a></p>
		</div>
	  </div>
	</div>

	<div class="container-fluid">	
	  <div class="span5 sidebar">
		<div class="well">
			<h3>Blogroll</h3>
			<ul>
								<li><a href="http://x-wei.github.com">x-wei</a></li>
								<li><a href="http://farseerfc.github.com/">farseerfc</a></li>
							</ul>
			<div class="social">
			<h3>Social</h3>
			<ul>
								<li><a href="https://github.com/hyhx2008">github</a></li>
							</ul>
			</div>
			
		</div>
		
		<div class="well">
			<div class="search_sidebar">
				<li class="nav-header"><h4><i class="icon-search"></i>Google Search</h4></li>
<!-- Put the following javascript before the closing </head> tag. -->
<script>
  (function() {
    var cx = '007947589229995882978:padodsakamc';
    var gcse = document.createElement('script'); gcse.type = 'text/javascript'; gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//www.google.com/cse/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(gcse, s);
  })();
</script>
<!-- Place this tag where you want both of the search box and the search results to render -->
<gcse:search></gcse:search>
			</div>

			<div class="google_ads">
				<li class="nav-header"><h4><i class="icon-search"></i>Google Ads</h4></li>
<script type="text/javascript"><!--
google_ad_client = "ca-pub-5617943900713834";
/* HY&#39;s github blog */
google_ad_slot = "7280262031";
google_ad_width = 160;
google_ad_height = 600;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
			</div>
		</div>

	  </div>
	  <div class="content">
							<div class='article'>
		<div class="page-header"><h1>算法导论第15章习题答案</h1></div>
		<div class="well small">Permalink: <a class="more" href="http://hyhx2008.github.com/suan-fa-dao-lun-di-15zhang-xi-ti-da-an.html">2013-05-07 09:51:00</a>
by <a class="url fn" href="http://hyhx2008.github.com/author/hyhx2008.html">hyhx2008</a>in <a href="http://hyhx2008.github.com/category/clrs.html">clrs</a>
tags: <a href="http://hyhx2008.github.com/tag/clrs.html">clrs</a> <a href="http://hyhx2008.github.com/tag/algorithm.html">algorithm</a> </div>
		<div><p><strong>15.2-2</strong></p>
<p>Q:请给出一个递归算法MATRIX-CHAIN-MULTIPLY(A,s,i,j)，使之在给出矩阵序列&lt;A1,A2,...,An&gt;，和由MATRIX-CHAIN-ORDER计算出的表s，
以及下标i和j后，能得出一个最有的矩阵链乘法。(初始调用为MATRIX-CHAIN-MULTIPLY(A,s,1,n))。</p>
<p>A:模仿PRINT-OPTIMAL-PARENS(s,i,j)即可。伪代码:</p>
<div class="highlight"><pre><span class="n">MATRIX</span><span class="o">-</span><span class="n">CHAIN</span><span class="o">-</span><span class="n">MULTIPLY</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="n">i</span><span class="o">=</span><span class="n">j</span> <span class="n">then</span> <span class="k">return</span> <span class="n">Ai</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="n">MATRIX</span><span class="o">-</span><span class="n">CHAIN</span><span class="o">-</span><span class="n">MULTIPLY</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span><span class="o">*</span><span class="n">MATRIX</span><span class="o">-</span><span class="n">CHAIN</span><span class="o">-</span><span class="n">MULTIPLY</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p><strong>15.4-5</strong></p>
<p>Q:请给出一个O(n^2)时间的算法，使之能找出一个n个数的序列中最长的单调递增子序列。</p>
<p>A:这里给出两种算法。</p>
<p>方法1:假设这n个数存在数组X中，首先将这n个数按单调递增的顺序排序，将排好序的数组存于Y中。
然后通过计算X和Y的最长公共子序列即可找到答案。</p>
<p>方法2:直接利用动态规划的思想。设f(i)为以第i个数结尾的最长单调递增子序列的长度，
则f(i)=max(f(k)+1, 其中k&lt;i且X[k]&lt;X[i])，如果在1到i-1内找不到符合条件的k，那么f(i)就只能等于1了。
为了方便最后构造最长子序列，还需要另一个数组pre[i]存储以第i个数结尾的最长递增子序列的倒数第2个数。
伪代码:</p>
<div class="highlight"><pre><span class="n">LIS</span><span class="o">-</span><span class="n">Length</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">max_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">f</span><span class="p">[</span><span class="mf">1.</span><span class="p">.</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">pre</span><span class="p">[</span><span class="mf">1.</span><span class="p">.</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">n</span> <span class="k">do</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span> <span class="k">do</span>
            <span class="k">if</span> <span class="n">X</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">&lt;</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="n">and</span> <span class="n">f</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span> <span class="o">&gt;</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="n">then</span>
            <span class="p">{</span>
                <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
                <span class="n">pre</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
            <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">n</span> <span class="k">do</span>
        <span class="k">if</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">max</span> <span class="n">then</span>
            <span class="n">max</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">max_i</span> <span class="o">=</span> <span class="n">i</span>
    <span class="k">return</span> <span class="n">max</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">LIS</span><span class="o">-</span><span class="n">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="n">pre</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">LIS</span><span class="o">-</span><span class="n">print</span><span class="p">(</span><span class="n">pre</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="n">print</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p><strong>15.4-6</strong></p>
<p>Q:请给出一个O(nlgn)时间的算法，使之能找出一个n个数的序列中最长的单调递增子序列。
(提示:观察长度为i的一个候选因子序列的最后一个元素，它至少与长度为i-1的一个候选子序列的最后一个元素一样大。通过把候选子序列与输入序列相连接来维护它们)。</p>
<p>A:这个提示看了好几遍也没有看懂说的是什么意思，大概是翻译的问题吧。总之需要将算法改进到O(nlgn)的复杂度。
自己想不到好的办法，百度了一下，想法还是挺巧妙的，用一个数组D[len]记录len长的递增子序列的最小末尾元素。
只需要从1到n一遍扫描中间加上二分查找，可以得到O(nlgn)的算法。这里不详细讨论，附上一个连接:</p>
<p><a class="reference external" href="http://blog.csdn.net/ssjhust123/article/details/7798737">最长递增子序列</a></p>
</div>
		<div>
			<h2>Comments</h2>
		 				<div id="disqus_thread"></div>					<div>
	</div>	
		<footer>
		  <p> Powered by <a href="http://alexis.notmyidea.org/pelican/">Pelican</a>, theme based on <a href="http://twitter.github.com/bootstrap/">Bootstrap, from Twitter</a>.</p>
		  <p>&copy; hyhx2008 2011</p>
		</footer>
	  </div>
   
	</div>
</body>
</html>