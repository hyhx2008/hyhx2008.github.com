<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>H.y's Blog</title>
	<meta name="description" content="">
	<meta name="author" content="hyhx2008">

	<!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
	<!--[if lt IE 9]>
		<script src="http://hyhx2008.github.com/theme/html5.js"></script>
	<![endif]-->

	<!-- Le styles -->
	<link href="http://hyhx2008.github.com/theme/bootstrap.min.css" rel="stylesheet">
	<link href="http://hyhx2008.github.com/theme/local.css" rel="stylesheet">
	<link href="http://hyhx2008.github.com/theme/pygments.css" rel="stylesheet">
	<script>var _gaq=[['_setAccount','UA-36075477-1'],['_trackPageview']];(function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];g.src='//www.google-analytics.com/ga.js';s.parentNode.insertBefore(g,s)}(document,'script'))</script>
	<script type="text/javascript">
	var disqus_identifier = "suan-fa-dao-lun-di-6789zhang-xi-ti-da-an.html";
	(function() {
		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		dsq.src = 'http://hysblog.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	})();
</script>
		
	<link rel="shortcut icon" href="http://hyhx2008.github.com/theme/images/icons/icon1.png">
</head>
<body>
		<a href="https://github.com/hyhx2008"><img style="position: absolute; top: 39px; right: 0; border: 0;" src="http://s3.amazonaws.com/github/ribbons/forkme_right_white_ffffff.png" alt="Fork me on GitHub" /></a>
	<div class="topbar">
	  <div class="topbar-inner">
		<div class="container-fluid">
		  <a class="brand" href="http://hyhx2008.github.com/index.html">H.y's Blog</a>
			<ul class="nav">
																										<li class="active"><a href="http://hyhx2008.github.com/category/clrs.html">clrs</a></li>
									<li ><a href="http://hyhx2008.github.com/category/intern.html">intern</a></li>
									<li ><a href="http://hyhx2008.github.com/category/my.html">my</a></li>
									<li ><a href="http://hyhx2008.github.com/category/peersim.html">peersim</a></li>
									<li ><a href="http://hyhx2008.github.com/category/raspberry-pi.html">raspberry-pi</a></li>
									<li ><a href="http://hyhx2008.github.com/category/tech.html">tech</a></li>
									<li ><a href="http://hyhx2008.github.com/category/ubuntu.html">ubuntu</a></li>
							</ul>
			<p class="pull-right"><a href="http://hyhx2008.github.com/archives.html">[archives]</a> <a href="http://hyhx2008.github.com/tags.html">[tags]</a></p>
		</div>
	  </div>
	</div>

	<div class="container-fluid">	
	  <div class="span5 sidebar">
		<div class="well">
			<h3>Blogroll</h3>
			<ul>
								<li><a href="http://x-wei.github.com">x-wei</a></li>
								<li><a href="http://farseerfc.github.com/">farseerfc</a></li>
							</ul>
			<div class="social">
			<h3>Social</h3>
			<ul>
								<li><a href="https://github.com/hyhx2008">github</a></li>
							</ul>
			</div>
			
		</div>
		
		<div class="well">
			<div class="search_sidebar">
				<li class="nav-header"><h4><i class="icon-search"></i>Google Search</h4></li>
<!-- Put the following javascript before the closing </head> tag. -->
<script>
  (function() {
    var cx = '007947589229995882978:padodsakamc';
    var gcse = document.createElement('script'); gcse.type = 'text/javascript'; gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//www.google.com/cse/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(gcse, s);
  })();
</script>
<!-- Place this tag where you want both of the search box and the search results to render -->
<gcse:search></gcse:search>
			</div>

			<div class="google_ads">
				<li class="nav-header"><h4><i class="icon-search"></i>Google Ads</h4></li>
<script type="text/javascript"><!--
google_ad_client = "ca-pub-5617943900713834";
/* HY&#39;s github blog */
google_ad_slot = "7280262031";
google_ad_width = 160;
google_ad_height = 600;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
			</div>
		</div>

	  </div>
	  <div class="content">
							<div class='article'>
		<div class="page-header"><h1>算法导论第6,7,8,9章习题答案</h1></div>
		<div class="well small">Permalink: <a class="more" href="http://hyhx2008.github.com/suan-fa-dao-lun-di-6789zhang-xi-ti-da-an.html">2013-04-19 17:20:00</a>
by <a class="url fn" href="http://hyhx2008.github.com/author/hyhx2008.html">hyhx2008</a>in <a href="http://hyhx2008.github.com/category/clrs.html">clrs</a>
tags: <a href="http://hyhx2008.github.com/tag/clrs.html">clrs</a> <a href="http://hyhx2008.github.com/tag/algorithm.html">algorithm</a> </div>
		<div><p><strong>6.5-6</strong></p>
<p>Q:说明如何使用优先级队列来实现一个先进先出队列，另说明如何用优先级队列来实现栈。</p>
<p>A:队列的性质是先进先出，所以维护一个最小优先级队列，给先进队的元素赋一个小的优先级，每插入一个新的元素优先级加1。
出队时取优先级最小的元素并维护优先级队列即可。栈的实现同理。</p>
<p><strong>6.5-7</strong></p>
<p>Q:HEAP-DELETE(A,i)操作将结点i中的项从堆A中删去。对含n个元素的最大堆，请给出时间为O(lgn)的HEAP-DELETE的实现。</p>
<p>A:类似于堆排序时做的操作，将要删除的结点和堆的最后一个结点交换，将其删除后维护堆的性质。伪代码:</p>
<div class="highlight"><pre><span class="n">HEAP</span><span class="o">-</span><span class="n">DELETE</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">heap</span><span class="o">-</span><span class="n">size</span><span class="p">[</span><span class="n">A</span><span class="p">]];</span>
    <span class="n">heap</span><span class="o">-</span><span class="n">size</span><span class="p">[</span><span class="n">A</span><span class="p">]</span> <span class="o">=</span> <span class="n">heap</span><span class="o">-</span><span class="n">size</span><span class="p">[</span><span class="n">A</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">key</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="k">if</span> <span class="n">key</span> <span class="o">&lt;=</span> <span class="n">A</span><span class="p">[</span><span class="n">PARENT</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="n">then</span>         <span class="c1">//放在i位置的新元素应该在堆更下面的位置</span>
        <span class="n">MAX</span><span class="o">-</span><span class="n">HEAPIFY</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">i</span><span class="p">);</span>
    <span class="k">else</span>                                <span class="c1">//放在i位置的新元素应该在堆更上面的位置</span>
        <span class="k">while</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">1</span> <span class="n">and</span> <span class="n">A</span><span class="p">[</span><span class="n">PARENT</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">&lt;</span> <span class="n">key</span> <span class="k">do</span>
        <span class="p">{</span>
            <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">PARENT</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">PARENT</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p><strong>6-3 Young氏矩阵</strong></p>
<p>Q:一个 m x n 的Young氏矩阵(Young tableau)是一个 m x n 的矩阵，其中每一行的数据都从左到右排序，每一列的数据都从上到下排序。
Young氏矩阵中可能会有一些 ∞ 的数据项，表示不存在的元素。所以，Young氏矩阵可以用来存放 r &lt;= mn个有限的数。请给出一个运行时间为O(m+n)的算法，
来决定一个给定的数是否存在于一个给定的 m x n 的Young氏矩阵内。</p>
<p>A:我们可以用给定的数和Young氏矩阵中最右上角的那个数比，如果给定的数比较大，则该数不可能存在于最上面那行；如果给定的数比较下，那么该数不可能存在于最右边那列。
这样每次比较就可以排除一行或者一列。重复此过程，直到找到给定的数或者所有的行和列都被排除了为止。伪代码:</p>
<div class="highlight"><pre><span class="n">Search</span><span class="o">-</span><span class="n">Young</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>

    <span class="k">if</span> <span class="n">x</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="n">then</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="n">then</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="n">then</span> <span class="k">return</span> <span class="n">Search</span><span class="o">-</span><span class="n">Young</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">x</span><span class="p">);</span>
        <span class="k">else</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="n">then</span>
        <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="n">then</span> <span class="k">return</span> <span class="n">Search</span><span class="o">-</span><span class="n">Young</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">x</span><span class="p">);</span>
        <span class="k">else</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Search</span><span class="o">-</span><span class="n">Young</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p><strong>7-6 对区间的模糊排序</strong></p>
<p>Q:考虑这样一种排序问题,即无法准确的知道等排序的各个数字到底是多少。对于其中的每个数字,我们只知道它落在实轴上的某个区间内。
亦即，给定的n个形如[ai, bi]的闭区间，其中ai ≤ bi。算法的目标是对这些区间进行模糊排序(fuzzy-sort)，亦即，
产生各区间的一个排序 &lt;i1, i2, i3, i4,…in &gt;，使得存在一个 cj ∈[ai, bi]，满足c1≤c2≤…≤cn。</p>
<p>为n个区间的模糊排序设计一个算法，你的算法应该具有算法的一般结构，它可以快速排序左部端点(即各ai)，
也要能充分利用重叠区间来改善运行时间。(随着各区间重叠得越来越多，对各区间的排序的问题会变得越来越容易，你的算法应该能充分利用这种重叠。)</p>
<p>A:算法的思想是仿照快速排序对各个区间进行排序，不同的地方，也是本题的关键在于如何利用重叠区间来改善运行时间。</p>
<p>很容易可以想到，如果两个区间有重叠，那么它们之间的顺序可以是任意的，即可以将这两个区间视作相等。对于区间[ai,bi]，[aj,bj]，有下列三种情况:</p>
<p>1&gt; if (bi&lt;aj) then [ai,bi]&lt;[aj,bj]</p>
<p>2&gt; else if (ai&gt;bj) then [ai,bi]&gt;[aj,bj]</p>
<p>3&gt; else [ai,bi] = [aj,bj]</p>
<p>算法与快速排序稍有不同，由于可能存在许多相等的区间，我们改为三路快速排序，即每次partition进行划分时，
将区间分为三类，左边部分是小于pivot的，中间一部分是等于pivot的，右边部分是大于pivot的。
由于中间的那一部分里的所有区间相等，则它们必须存在同一段公共的重叠部分，所以pivot的选取要特别注意。</p>
<p>我们首先选取一个区间作为pivot，然后在划分时，如果有某个区间和pivot有重叠，则将其加入中间的那一部分，然后提取重叠区域作为新的pivot继续划分。伪代码:</p>
<div class="highlight"><pre><span class="n">fuzzy</span><span class="o">-</span><span class="n">sort</span><span class="p">(</span><span class="n">Intervals</span><span class="p">,</span><span class="n">beg</span><span class="p">,</span><span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="n">beg</span> <span class="o">&lt;</span> <span class="n">end</span> <span class="n">then</span>
    <span class="p">{</span>
        <span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">)</span> <span class="o">=</span> <span class="n">partition</span><span class="p">(</span><span class="n">Intervals</span><span class="p">,</span><span class="n">beg</span><span class="p">,</span><span class="n">end</span><span class="p">);</span>   <span class="c1">//p,q为将区间数组分割为三部分的两个分界</span>
        <span class="n">fuzzy</span><span class="o">-</span><span class="n">sort</span><span class="p">(</span><span class="n">Intervals</span><span class="p">,</span><span class="n">beg</span><span class="p">,</span><span class="n">p</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">fuzzy</span><span class="o">-</span><span class="n">sort</span><span class="p">(</span><span class="n">Intervals</span><span class="p">,</span><span class="n">q</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">end</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">partition</span><span class="p">(</span><span class="n">Intervals</span><span class="p">,</span><span class="n">beg</span><span class="p">,</span><span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">pivot</span> <span class="o">=</span> <span class="n">Intervals</span><span class="p">[</span><span class="n">end</span><span class="p">];</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">beg</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">end</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>

    <span class="n">i</span> <span class="o">=</span> <span class="n">beg</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="n">q</span><span class="p">)</span> <span class="k">do</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="n">Intervals</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">b</span> <span class="o">&lt;</span> <span class="n">pivot</span><span class="p">.</span><span class="n">a</span> <span class="n">then</span>        <span class="c1">//当前区间小于pivot</span>
        <span class="p">{</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
            <span class="n">exchange</span><span class="p">(</span><span class="n">Intervals</span><span class="p">[</span><span class="n">p</span><span class="p">],</span><span class="n">Intervals</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span><span class="k">else</span> <span class="k">if</span> <span class="n">Intervals</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">pivot</span><span class="p">.</span><span class="n">b</span> <span class="n">then</span>  <span class="c1">//当前区间大于pivot</span>
        <span class="p">{</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="n">exchange</span><span class="p">(</span><span class="n">Intervals</span><span class="p">[</span><span class="n">q</span><span class="p">],</span><span class="n">Intervals</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span><span class="k">else</span>                                   <span class="c1">//当前区间等于pivto，需要更新pivot的范围值</span>
        <span class="p">{</span>
            <span class="n">pivot</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">pivot</span><span class="p">.</span><span class="n">a</span><span class="p">,</span><span class="n">Intervals</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">a</span><span class="p">);</span>
            <span class="n">pivot</span><span class="p">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">pivot</span><span class="p">.</span><span class="n">b</span><span class="p">,</span><span class="n">Intervals</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">b</span><span class="p">);</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">);</span>

<span class="p">}</span>
</pre></div>
<p><strong>8.2-4</strong></p>
<p>Q:请给出一个算法，使之对于给定的介于0到k之间的n个整数进行预处理，并能在O(1)时间内，回答出输入的整数中有多少个落在区间[a..b]内。你给出的算法的预处理时间应该是O(n+k)。</p>
<p>A:同计数排序的预处理一样，用一个数组C，C[i]保存小于等于i的整数的个数，那么在[a..b]范围内的整数个数就为C[b]-C[a] + (等于a的整数的个数)。</p>
<p><strong>8.4-4</strong></p>
<p>Q:在单位圆内有n个点，pi=(xi, yi)，使得0&lt;xi^2 + yi^2 ≤1, i = 1,2,....,n。
假设所有点是均匀分布的，亦即，某点落在圆的任一区域中的概率与该区域的面积成正比。
请设计一个Θ(n)期望的算法，来根据点到原点的距离di=sqrt(xi^2 + yi^2)对n个点排序。</p>
<p>A:题目给的提示是在桶排序算法中，设计适当的桶尺寸，以反映各个点在单位元中的均匀分布。
那么我们只需要把单位圆划分成n个面积相等的同心圆(环)即可。</p>
<p>把一个圆化为n个面积相等的同心圆(环)，则每个圆(环)的面积为1/n。很容易得出各个圆环的半径Rk=sqrt(k/npi)。</p>
<p><strong>8-3 排序不同长度的数据项</strong></p>
<p>Q:a)给定一个整数数组，其中不同的整数中包含的数字个数可能不同，但是该数组中，所有整数中总的数字数为n。说明如何在O(n)时间内对该数组进行排序。</p>
<p>b)给定一个字符串数组，其中不同的串包含的字符个数可能不同，但所有串中总的字符个数为n。说明如何在O(n)时间内对该数组进行排序。
(注意此处的顺序是指标准的字母顺序，例如，a &lt; ab &lt; b)</p>
<p>A:a)先用计数排序算法按数字位数排序O(n)，再用基数排序的方法分别对每个桶中的元素排序O(n)。</p>
<p>b)递归使用计数排序，先依据第一个字母进行排序，首字相同的放在同一组，再对每一组分别使用计数排序的方法比较第二个字母。以此类推。</p>
<p><strong>8-4 水壶</strong></p>
<p>Q:假设给定了n个红色的水壶和n个蓝色的水壶，它们的形状和尺寸都不相同。
所有红色水壶中所盛水的量都不一样，蓝色水壶也是一样。此外，对于每个红色的水壶，
都有一个对应的蓝色水壶，两者所盛的水量是一样的。反之亦然。
你的任务是将所盛水量一样的红色水壶和蓝色水壶找出来。为了达到这一目的，可以执行如下操作:
挑选出一对水壶，其中一个是红色的，另一个是蓝色的：将红色水壶中倒满水；再将水倒入到蓝色的水壶中。
通过这个操作，可以判断出来这两只水壶的容量哪一个大，或者是一样大。假设这样的比较需要一个时间单位。
你的目标是找出一个算法，它通过执行最少次数的比较，来确定分组和配对问题。记住不能直接比较两个红色的或两个蓝色的水壶。</p>
<p>给出一个随机化的算法，其期望的比较次数为O(nlgn)。</p>
<p>A:由于每个红色水壶和蓝色水壶都有一组配对，所以只需要对两组水壶分别排序即可。但是不允许直接比较两个相同颜色的水壶。
这里采用快速排序的思想，先从红色的水壶中随机选择一个作为蓝pivot，然后在蓝色水壶中查找和该红色水壶容量一样的那个做红pivot。
利用红pivot对蓝色水壶进行partition，再用蓝pivot对红色水壶进行partition。其余过程类似于快速排序。</p>
<p><strong>8-5 平均排序</strong></p>
<p>Q:假设我们不是要排序一个数组，而只是要求数组中的元素一般情况下都是层递增序的。
更准确地说，称一个包含n个元素的数组A为k排序的(k-sorted)，如果对所有i=1,2, ..., n-k，有下式成立:</p>
<div class="figure">
<img alt="figure" src="../statics/pics/chap6-9_1.png" />
</div>
<p>a)给出一个算法，它能在O(nlg(n/k))时间内，对一个n元素的数组进行k排序。</p>
<p>b)说明一个长度为n的k排序的数组可以在O(nlgk)内排序。</p>
<p>A:a)容易证明，一个n元素的数组是k排序的，当且仅当对所有i=1,2, .... n-k 有 A[i] ≤ A[i+k]。</p>
<p>所以我们只需要将该数组分为k个独立的小组，每个分组大小为n/k。 每个大小为n/k的分组进行排序的时间复杂度为O(n/k*lg(n/k))，
那么k个分组总的时间复杂度为k*O(n/k*lg(n/k)) =  O(nlg(n/k))。</p>
<p>b)在a中对k个分组用一个k元素的最小堆进行k路合并，每次提取最小值和增加一个新元素的时间复杂为O(lgk)。
总共需要n次提取最小值和增加新元素的操作，则对应的时间复杂度为O(nlgk)。</p>
<p><strong>9.1-1</strong></p>
<p>Q:利用 n+lgn-2 次比较，找到n个元素中的第2小元素。</p>
<p>A:这道题的方法略难想，看了别人的解法，自己解释不清楚。这里附一个参考的链接。</p>
<p><a class="reference external" href="http://blog.csdn.net/mishifangxiangdefeng/article/details/7983809">算法导论 9.1-1 求第二小元素</a></p>
<p><strong>9.3-5</strong></p>
<p>Q:假设已经有了一个用于求解中位数的“黑箱”子程序，它在最坏情况下需要线性运行时间。
写出一个能解决任意顺序统计量的选择问题的线性时间算法。</p>
<p>A:算法类似于快速排序的partition，只是每次pivot的选择可以用“黑箱”程序求出的中位数。
假设“黑箱”程序为median(A,p,q)，伪代码:</p>
<div class="highlight"><pre><span class="n">Select</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">pivot</span> <span class="o">=</span> <span class="n">median</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">);</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">return</span> <span class="n">pivot</span><span class="p">;</span>

    <span class="n">Partition</span> <span class="n">A</span><span class="p">[</span><span class="n">p</span><span class="p">..</span><span class="n">q</span><span class="p">]</span> <span class="n">around</span> <span class="n">pivot</span><span class="p">;</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="n">then</span>
        <span class="k">return</span> <span class="n">Slelct</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">p</span><span class="p">,(</span><span class="n">p</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">i</span><span class="p">);</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="nf">Select</span><span class="p">(</span><span class="n">A</span><span class="p">,(</span><span class="n">p</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">i</span><span class="o">-</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p><strong>9.3-6</strong></p>
<p>Q:对一个含有n个元素的集合来说，所谓k分位数(the kth quantile)，就是能把已排序的集合分成k个大小相等的集合的k-1个顺序统计量。
给出一个能列出某一集合的k分位数的O(nlgk)时间的算法。</p>
<p>A:将n个元素划分为k个大小相等的集合，那么每个集合的元素个数为t=n/k，则题目要求的就是这n个元素中第t，2t，...，(k-1)t大的数。</p>
<p>如果按顺序依次求这k-1个数需要的时间为(k-1)*n。我们可以理由二分法来改进，首先查找第(k/2)个分位数，
然后以这个分位数为pivot将n个元素分为两段，分别对这两段用同样的方法来找其他分位数。可以将时间降为O(nlgk)。</p>
<p><strong>9.3-7</strong></p>
<p>Q:给出一个O(n)时间的算法，在给定一个有n个不同数字的集合S以及一个正整数 k&lt;=n 后，它能确定出S中最接近其中位数的k个数。</p>
<p>A:首先找到S中的中位数，然后计算S中每个数与中位数差的绝对值，存于另一个数组A中；求出A中第k小的数x，
最后通过找出S中与中位数的差的绝对值小于x的数即为所求。</p>
<p><strong>9.3-8</strong></p>
<p>Q:设X[1..n]和Y[1..n]为两个数组，每个都包含n个已排好序的数。给出一个求数组X和Y中所有2n个元素的中位数的、O(lgn)时间的算法。</p>
<p>A:我们先假设所求的中位数在X里，为X[k]。在数组X中，X[k]比X[1..k-1]这k-1个数大，比X[k+1..n]这n-k个数小。
那么如果X[k]两个数组共同的中位数，那么X[k]必须必Y中的n-k个数大、比k-1个数小，即 Y[n-k] &lt;= X[k] &lt;= Y[n-k+1]。
我们可以用这个方法检查X[k]是否就是所求的中位数。</p>
<p>如果X[k]比Y[n-k+1]还大，那么说明在X中比X[k]大的数X[k+1..n]都不符合条件；如果X[k]比Y[n-k]还小，那么说明X中比X[k]小的数X[1..k-1]都不符合条件。
利用二分法，每次可以排除一半的数。如果在X中找不到，那么再反过来在Y中以同样的方法查找。伪代码:</p>
<div class="highlight"><pre><span class="n">TWo</span><span class="o">-</span><span class="n">ARRAY</span><span class="o">-</span><span class="n">MeDIAN</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">median</span> <span class="o">=</span> <span class="n">Find</span><span class="o">-</span><span class="n">Median</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
    <span class="k">if</span> <span class="n">median</span> <span class="o">=</span> <span class="n">NOT_FOUND</span> <span class="n">then</span>
        <span class="n">median</span> <span class="o">=</span> <span class="n">Find</span><span class="o">-</span><span class="n">Median</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
    <span class="n">retrun</span> <span class="n">median</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Find</span><span class="o">-</span><span class="n">Median</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">low</span><span class="p">,</span><span class="n">high</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="n">low</span> <span class="o">&gt;</span> <span class="n">high</span> <span class="n">then</span>
        <span class="k">return</span> <span class="n">NOT_FOUND</span><span class="p">;</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="n">low</span><span class="o">+</span><span class="n">high</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
        <span class="k">if</span> <span class="n">k</span><span class="o">=</span><span class="n">n</span> <span class="n">and</span> <span class="n">X</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">Y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="n">then</span>
         <span class="k">return</span> <span class="n">X</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">n</span> <span class="n">and</span> <span class="n">Y</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="n">k</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">X</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">Y</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="n">then</span>
                <span class="k">return</span> <span class="n">X</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
            <span class="k">if</span> <span class="n">X</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">Y</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="n">then</span>
                <span class="k">return</span> <span class="n">Find</span><span class="o">-</span><span class="n">Median</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">low</span><span class="p">,</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
            <span class="k">if</span> <span class="n">X</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">Y</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="n">k</span><span class="p">]</span> <span class="n">then</span>
                <span class="k">return</span> <span class="n">Find</span><span class="o">-</span><span class="n">Median</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">high</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>在网上还看到一个更加巧妙的改进:</p>
<p>递归求解该问题，解题规模不断减半，最后剩下4个元素时，得到问题的解。
分别取两个数组的中值midA和midB进行比较。
如果midA=midB，那么这个值就是结果。
否则，小的那个所在的数组去掉前面一半，大的那个去掉后面一半。
(对于两个数组的中值，共有n-1个元素，有n个元素比它大。但是对于min(minA,minB)，最多只有n-2个元素比它小，所以一定不是所求的结果，同理去掉大的一半)。
然后对剩余的两个数组，用同的方法求它们的中值，直到两个数组一共剩下4个元素。</p>
<p><strong>9.3-9</strong></p>
<p>Q:Olay教授是一家石油公司的顾问，这家公司正在计划建造一条由东向西的大型管道，它穿过一个有n口油井的油田。
从每口井中都有一条喷油管道沿最短路径与主管道直接连接(或南或北)，如下图所示。给定各口井的x坐标和y坐标，
应如何选择主管道的最优位置(使得各喷管长度总和最小的位置)？</p>
<div class="figure">
<img alt="figure" src="../statics/pics/chap6-9_2.png" />
</div>
<p>A:第一感觉是求中位数，但是也不知道为什么。百度了一下，看到一个非常好的解释:</p>
<p>为了简化这道题，不考虑油井的x坐标，假设所有的油井都在一条与管道垂直的线上。
假如有两个油井AB，分别在管道l的上下，那么不管这条管道在什么位置(只要在AB之间)，d[Al]+d[bl]=d[AB]。
根据以上规律，把每两个油井分为一组，第i组中的油井是（y坐标第i大的油井和第i小的油井），只要管道在每组的两个油井之间，就能保证长度总和最小。</p>
<p>设所有油井的y坐标(较小的)中位数为yi，由以上推理得出答案：</p>
<p>1&gt;如果油井的个数是奇数，让管道过yi位置。</p>
<p>2&gt;如果点的个数是偶数，让管道位于yi和yi+1之间的任意位置(包括这两点)。</p>
<p><strong>9-1 已排序的i个最大数</strong></p>
<p>Q:给定一个含n个元素的集合，我们希望能用一个基于比较的算法来找出按顺序排列的i个最大元素。
请找出能实现下列每一种方法的、具有最佳的渐进最坏情况运行时间的算法，并分析各种方法的运行时间。</p>
<p>A:a)对输入数排序，并列出i个最大的数。   排序算法最优为O(nlgn)。</p>
<p>b)对输入数建立一个优先级队列，并调用EXTRACT-MAX过程i次。  建堆O(n) + i次EXTRACT-MAX 为 O(n+i*lgn)。</p>
<p>c)利用一个顺序统计量算法来找到第i个最大元素，然后换分输入数组，再对i个最大数排序。  划分O(n) + i个数排序O(ilgi) 为O(n+ilgi)。</p>
<p><strong>9-2 带权中位数</strong></p>
<p>Q:求n个元素的带权中位数。</p>
<p>(因为不好打公式，这里我就大概解释一下什么是带权中位数。n个元素x1，x2，...，xn分别具有一个正的权重w1，w2，...，wn，且权重和为1。
带权中位数xk要满足比xk小的元素的权重和小于1/2，并且比xk大的元素的权重小于等于0.5)</p>
<p>A:方法1，先对n个元素进行排序，然后从头开始依次对每个元素进行验证，同时累加权重，看其满足不满足带权中位数的条件。该算法的复杂度为排序的O(nlgn)+验证的O(n)。</p>
<p>方法2，类似于快速排序中的partition，用中位数进行分割，然后累加一边的权重和，看其满足带权中位数的条件否，不满足的话舍去一半继续递分割查找。伪代码:</p>
<div class="highlight"><pre><span class="n">Find</span><span class="o">-</span><span class="n">w</span><span class="o">-</span><span class="n">Median</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">start</span><span class="p">,</span><span class="n">end</span><span class="p">,</span><span class="n">w</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">pivot</span> <span class="o">=</span> <span class="n">Find</span><span class="o">-</span><span class="n">Median</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">start</span><span class="p">,</span><span class="n">end</span><span class="p">);</span>
    <span class="n">Partition</span> <span class="n">X</span><span class="p">(</span><span class="n">from</span> <span class="n">start</span> <span class="n">to</span> <span class="n">end</span><span class="p">)</span> <span class="n">around</span> <span class="n">pivot</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sum</span> <span class="n">of</span> <span class="n">weight</span> <span class="n">start</span><span class="p">...</span><span class="n">mid</span><span class="o">-</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">w</span><span class="p">)</span> <span class="n">and</span> <span class="p">(</span><span class="n">sum</span> <span class="n">of</span> <span class="n">weight</span> <span class="n">start</span><span class="p">...</span><span class="n">mid</span> <span class="o">&gt;=</span> <span class="n">w</span><span class="p">)</span> <span class="n">then</span>
        <span class="k">return</span> <span class="n">pivot</span><span class="p">;</span>
    <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">sum</span> <span class="n">of</span> <span class="n">weight</span> <span class="n">start</span><span class="p">...</span><span class="n">mid</span><span class="o">-</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">w</span><span class="p">)</span> <span class="n">then</span>
        <span class="k">return</span> <span class="n">Find</span><span class="o">-</span><span class="n">w</span><span class="o">-</span><span class="n">Median</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">start</span><span class="p">,</span><span class="n">mid</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">w</span><span class="p">);</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="n">Find</span><span class="o">-</span><span class="n">w</span><span class="o">-</span><span class="n">Median</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">end</span><span class="p">,</span><span class="n">w</span> <span class="o">-</span> <span class="n">sum</span> <span class="n">of</span> <span class="n">weight</span> <span class="n">start</span><span class="p">...</span><span class="n">mid</span><span class="p">);</span>

<span class="p">}</span>

<span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">Find</span><span class="o">-</span><span class="n">w</span><span class="o">-</span><span class="n">Median</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>这道题后面还附了一个带权中位数的应用问题:</p>
<p><strong>邮局位置问题</strong></p>
<p>Q:邮局位置问题(post-office location problem)定义如下:已知n个点p1，p2，...，pn及与他们相联系的权重w1,w2，...，wn。
我们希望找到一点p(不一定是输入点中的一个)，使sum(wi*d(p,pi)) (i=1...n) 最小，此处d(a,b)表示点a与b之间的距离。</p>
<p>a)证明带权中位数是一维邮局位置问题的最佳解决方案，d(a,b) = | a-b | 。</p>
<p>b)找出二维邮局问题的最佳解决方案，其中所有的点都是(x,y)坐标对，并且d(a,b) = | xa-xb | + | ya-yb | 。</p>
<p>A:a)严格的证明不太会，这里给出一种容易理解的说明。假设各个点的权重都是整数的比例关系(同时将权重扩大足够大的倍数即可看出)，
那么通过将每个点复制其权重比例多个，一维邮局问题则变为9.3-9描述的输油管道问题。按照9.3-9中配对的想法，中位数一定是带权中位数复制后中的一个。</p>
<p>b)将x坐标和y坐标分别求一维邮局问题，得到的坐标对即为二维邮局问题的解。</p>
</div>
		<div>
			<h2>Comments</h2>
		 				<div id="disqus_thread"></div>					<div>
	</div>	
		<footer>
		  <p> Powered by <a href="http://alexis.notmyidea.org/pelican/">Pelican</a>, theme based on <a href="http://twitter.github.com/bootstrap/">Bootstrap, from Twitter</a>.</p>
		  <p>&copy; hyhx2008 2011</p>
		</footer>
	  </div>
   
	</div>
</body>
</html>