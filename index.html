<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>H.y's Blog</title>
	<meta name="description" content="">
	<meta name="author" content="hyhx2008">

	<!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
	<!--[if lt IE 9]>
		<script src="http://hyhx2008.github.com/theme/html5.js"></script>
	<![endif]-->

	<!-- Le styles -->
	<link href="http://hyhx2008.github.com/theme/bootstrap.min.css" rel="stylesheet">
	<link href="http://hyhx2008.github.com/theme/local.css" rel="stylesheet">
	<link href="http://hyhx2008.github.com/theme/pygments.css" rel="stylesheet">
	<script>var _gaq=[['_setAccount','UA-36075477-1'],['_trackPageview']];(function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];g.src='//www.google-analytics.com/ga.js';s.parentNode.insertBefore(g,s)}(document,'script'))</script>
			
	<link rel="shortcut icon" href="http://hyhx2008.github.com/theme/images/icons/icon1.png">
</head>
<body>
		<a href="https://github.com/hyhx2008"><img style="position: absolute; top: 39px; right: 0; border: 0;" src="http://s3.amazonaws.com/github/ribbons/forkme_right_white_ffffff.png" alt="Fork me on GitHub" /></a>
	<div class="topbar">
	  <div class="topbar-inner">
		<div class="container-fluid">
		  <a class="brand" href="http://hyhx2008.github.com/index.html">H.y's Blog</a>
			<ul class="nav">
																										<li ><a href="http://hyhx2008.github.com/category/clrs.html">clrs</a></li>
									<li ><a href="http://hyhx2008.github.com/category/intern.html">intern</a></li>
									<li ><a href="http://hyhx2008.github.com/category/my.html">my</a></li>
									<li ><a href="http://hyhx2008.github.com/category/peersim.html">peersim</a></li>
									<li ><a href="http://hyhx2008.github.com/category/tech.html">tech</a></li>
									<li ><a href="http://hyhx2008.github.com/category/ubuntu.html">ubuntu</a></li>
							</ul>
			<p class="pull-right"><a href="http://hyhx2008.github.com/archives.html">[archives]</a> <a href="http://hyhx2008.github.com/tags.html">[tags]</a></p>
		</div>
	  </div>
	</div>

	<div class="container-fluid">	
	  <div class="span5 sidebar">
		<div class="well">
			<h3>Blogroll</h3>
			<ul>
								<li><a href="http://x-wei.github.com">x-wei</a></li>
								<li><a href="http://farseerfc.github.com/">farseerfc</a></li>
							</ul>
			<div class="social">
			<h3>Social</h3>
			<ul>
								<li><a href="https://github.com/hyhx2008">github</a></li>
							</ul>
			</div>
			
		</div>
		
		<div class="well">
			<div class="search_sidebar">
				<li class="nav-header"><h4><i class="icon-search"></i>Google Search</h4></li>
<!-- Put the following javascript before the closing </head> tag. -->
<script>
  (function() {
    var cx = '007947589229995882978:padodsakamc';
    var gcse = document.createElement('script'); gcse.type = 'text/javascript'; gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//www.google.com/cse/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(gcse, s);
  })();
</script>
<!-- Place this tag where you want both of the search box and the search results to render -->
<gcse:search></gcse:search>
			</div>

			<div class="google_ads">
				<li class="nav-header"><h4><i class="icon-search"></i>Google Ads</h4></li>
<script type="text/javascript"><!--
google_ad_client = "ca-pub-5617943900713834";
/* HY&#39;s github blog */
google_ad_slot = "7280262031";
google_ad_width = 160;
google_ad_height = 600;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
			</div>
		</div>

	  </div>
	  <div class="content">
			<div class="page-header"><h1> H.y's Blog </h1></div>			
<div class='article'>
	<h2>算法导论第10-14章习题答案</h2>
	<div class="well small">Permalink: <a class="more" href="http://hyhx2008.github.com/suan-fa-dao-lun-di-10-14zhang-xi-ti-da-an.html">2013-05-11 15:12:00</a>
by <a class="url fn" href="http://hyhx2008.github.com/author/hyhx2008.html">hyhx2008</a>in <a href="http://hyhx2008.github.com/category/clrs.html">clrs</a>
tags: <a href="http://hyhx2008.github.com/tag/clrs.html">clrs</a> <a href="http://hyhx2008.github.com/tag/algorithm.html">algorithm</a> </div>
	<div class="summary"><p><strong>10.1-6</strong></p>
<p>Q:说明如何用两个栈来实现一个队列，并分析有关队列操作的运行时间。</p>
<p>A:栈是先进后出，而队列是先进先出，一种自然的想法是，用一个栈来存储队列的元素，入队就和如栈一样；
出队的时候先将这个栈的元素依次压出另一个栈内，然后将栈顶元素(即队首)弹出，然后再依次倒回原先的栈内。
这样入队为O(1)，出队为O(n)。仔细想想，并不需要每次都将当前所有元素在两个栈内倒来倒去，
只需要入队用一个栈，出队用另一个栈: 入队操作即在第一个栈上执行入栈；出队操作时，若第二个栈不为空，则在第二个栈上执行出栈，
若第二个栈为空，则将第一个栈内的元素依次全部压入第二个栈内。这样入队出队操作都为O(1)的复杂度。</p>
<p><strong>10.1-7</strong></p>
<p>Q:说明如何用两个队列来实现一个栈，并分析有关栈操作的运行时间。</p>
<p>A:一种自然的想法，类似于上一题，用一个队存储，另一个队列作为临时空间。入栈时就向第一个队列中插入元素；
出栈时，先将第一个队列中除队尾(栈顶)的元素依次出队后进入第二个队列，然后将队尾(栈顶 ...</p> <a class="btn primary xsmall" href="http://hyhx2008.github.com/suan-fa-dao-lun-di-10-14zhang-xi-ti-da-an.html">more…</a>
	</div>
</div>	
<div class='article'>
	<h2>算法导论第15章习题答案</h2>
	<div class="well small">Permalink: <a class="more" href="http://hyhx2008.github.com/suan-fa-dao-lun-di-15zhang-xi-ti-da-an.html">2013-05-07 09:51:00</a>
by <a class="url fn" href="http://hyhx2008.github.com/author/hyhx2008.html">hyhx2008</a>in <a href="http://hyhx2008.github.com/category/clrs.html">clrs</a>
tags: <a href="http://hyhx2008.github.com/tag/clrs.html">clrs</a> <a href="http://hyhx2008.github.com/tag/algorithm.html">algorithm</a> </div>
	<div class="summary"><p><strong>15.2-2</strong></p>
<p>Q:请给出一个递归算法MATRIX-CHAIN-MULTIPLY(A,s,i,j)，使之在给出矩阵序列&lt;A1,A2,...,An&gt;，和由MATRIX-CHAIN-ORDER计算出的表s，
以及下标i和j后，能得出一个最有的矩阵链乘法。(初始调用为MATRIX-CHAIN-MULTIPLY(A,s,1,n))。</p>
<p>A:模仿PRINT-OPTIMAL-PARENS(s,i,j)即可。伪代码:</p>
<div class="highlight"><pre><span class="n">MATRIX</span><span class="o">-</span><span class="n">CHAIN</span><span class="o">-</span><span class="n">MULTIPLY</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="n">i</span><span class="o">=</span><span class="n">j</span> <span class="n">then</span> <span class="k">return</span> <span class="n">Ai</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="n">MATRIX</span><span class="o">-</span><span class="n">CHAIN</span><span class="o">-</span><span class="n">MULTIPLY</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">s</span><span class="p">[</span><span class="n">i ...</span></pre></div> <a class="btn primary xsmall" href="http://hyhx2008.github.com/suan-fa-dao-lun-di-15zhang-xi-ti-da-an.html">more…</a>
	</div>
</div>	
<div class='article'>
	<h2>算法导论第6,7,8,9章习题答案</h2>
	<div class="well small">Permalink: <a class="more" href="http://hyhx2008.github.com/suan-fa-dao-lun-di-6789zhang-xi-ti-da-an.html">2013-04-19 17:20:00</a>
by <a class="url fn" href="http://hyhx2008.github.com/author/hyhx2008.html">hyhx2008</a>in <a href="http://hyhx2008.github.com/category/clrs.html">clrs</a>
tags: <a href="http://hyhx2008.github.com/tag/clrs.html">clrs</a> <a href="http://hyhx2008.github.com/tag/algorithm.html">algorithm</a> </div>
	<div class="summary"><p><strong>6.5-6</strong></p>
<p>Q:说明如何使用优先级队列来实现一个先进先出队列，另说明如何用优先级队列来实现栈。</p>
<p>A:队列的性质是先进先出，所以维护一个最小优先级队列，给先进队的元素赋一个小的优先级，每插入一个新的元素优先级加1。
出队时取优先级最小的元素并维护优先级队列即可。栈的实现同理。</p>
<p><strong>6.5-7</strong></p>
<p>Q:HEAP-DELETE(A,i)操作将结点i中的项从堆A中删去。对含n个元素的最大堆，请给出时间为O(lgn)的HEAP-DELETE的实现。</p>
<p>A:类似于堆排序时做的操作，将要删除的结点和堆的最后一个结点交换，将其删除后维护堆的性质。伪代码:</p>
<div class="highlight"><pre><span class="n">HEAP</span><span class="o">-</span><span class="n">DELETE</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">heap</span><span class="o">-</span><span class="n">size</span><span class="p">[</span><span class="n">A</span><span class="p">]];</span>
    <span class="n">heap</span><span class="o">-</span><span class="n">size</span><span class="p">[</span><span class="n">A</span><span class="p">]</span> <span class="o">=</span> <span class="n">heap</span><span class="o">-</span><span class="n">size</span><span class="p">[</span><span class="n">A</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">key</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="k">if</span> <span class="n">key ...</span></pre></div> <a class="btn primary xsmall" href="http://hyhx2008.github.com/suan-fa-dao-lun-di-6789zhang-xi-ti-da-an.html">more…</a>
	</div>
</div>	
<div class='article'>
	<h2>算法导论第2章习题答案</h2>
	<div class="well small">Permalink: <a class="more" href="http://hyhx2008.github.com/suan-fa-dao-lun-di-2zhang-xi-ti-da-an.html">2013-04-18 17:00:00</a>
by <a class="url fn" href="http://hyhx2008.github.com/author/hyhx2008.html">hyhx2008</a>in <a href="http://hyhx2008.github.com/category/clrs.html">clrs</a>
tags: <a href="http://hyhx2008.github.com/tag/clrs.html">clrs</a> <a href="http://hyhx2008.github.com/tag/algorithm.html">algorithm</a> </div>
	<div class="summary"><p><strong>2.3-7</strong></p>
<p>Q:请给出一个运行时间为O(nlgn)的算法，使之能在一个由n个整数构成的集合S和另一个整数X时，判断出S中是否存在有两个其和等于X的元素。</p>
<p>A:首先将这n个数进行排序，然后依次对每个数查找是否存在另一个数与其的和为x，查找使用二分查找法。伪代码:</p>
<div class="highlight"><pre><span class="n">checkSums</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>  <span class="c1">//s为存放n个整数的集合</span>
<span class="p">{</span>
    <span class="n">sort</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>    <span class="c1">//排序</span>

    <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">n</span> <span class="k">do</span>
        <span class="k">if</span> <span class="n">binarySearch</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">x</span><span class="o">-</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="n">then</span>  <span class="c1">//二分查找</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>排序的复杂度为nlgn，二分查找的复杂度为lgn，执行n次就是nlgn，所以该算法的复杂度为O(nlgn)。</p>
<p><strong>2-4 逆序对</strong></p>
<p>Q:设A[1..n]是一个包含n个不同数的数组 ...</p> <a class="btn primary xsmall" href="http://hyhx2008.github.com/suan-fa-dao-lun-di-2zhang-xi-ti-da-an.html">more…</a>
	</div>
</div>	
<div class='article'>
	<h2>Ubuntu网络设置</h2>
	<div class="well small">Permalink: <a class="more" href="http://hyhx2008.github.com/ubuntuwang-luo-she-zhi.html">2013-04-15 21:35:00</a>
by <a class="url fn" href="http://hyhx2008.github.com/author/hyhx2008.html">hyhx2008</a>in <a href="http://hyhx2008.github.com/category/ubuntu.html">ubuntu</a>
tags: <a href="http://hyhx2008.github.com/tag/ubuntu.html">ubuntu</a> <a href="http://hyhx2008.github.com/tag/linux.html">linux</a> <a href="http://hyhx2008.github.com/tag/network.html">network</a> </div>
	<div class="summary"><p><strong>1.配置ip</strong></p>
<p>ubuntu的网络配置信息放在 /etc/network/interfaces 中;</p>
<p>如果配置动态获取ip，则在上述文件中加入以下内容：</p>
<div class="highlight"><pre><span class="go">auto eth0</span>
<span class="go">iface eth0 inet dhcp</span>
</pre></div>
<p>如果配置静态ip，则添加如下内容：</p>
<div class="highlight"><pre><span class="go">auto eth0</span>
<span class="go">iface eth0 inet static</span>
<span class="go">address 192.168.1.155</span>
<span class="go">netmask 255.255.255.0</span>
<span class="go">gateway 192.168.1.1</span>
</pre></div>
<p>要是配置生效，需要重启网卡：</p>
<div class="highlight"><pre><span class="go">ifconfig eth0 down</span>
<span class="go">ifconfig eth0 up</span>
</pre></div>
<p>接着用ifconfig命令查看ip是否配置成功，若还有没有配置成功，则需重启下网络服务</p>
<div class="highlight"><pre><span class="go">/etc ...</span></pre></div> <a class="btn primary xsmall" href="http://hyhx2008.github.com/ubuntuwang-luo-she-zhi.html">more…</a>
	</div>
</div>	
<div class='article'>
	<h2>Ubuntu下Java的安装与配置</h2>
	<div class="well small">Permalink: <a class="more" href="http://hyhx2008.github.com/ubuntuxia-javade-an-zhuang-yu-pei-zhi.html">2013-04-15 21:03:00</a>
by <a class="url fn" href="http://hyhx2008.github.com/author/hyhx2008.html">hyhx2008</a>in <a href="http://hyhx2008.github.com/category/ubuntu.html">ubuntu</a>
tags: <a href="http://hyhx2008.github.com/tag/ubuntu.html">ubuntu</a> <a href="http://hyhx2008.github.com/tag/linux.html">linux</a> <a href="http://hyhx2008.github.com/tag/java.html">java</a> </div>
	<div class="summary"><p>第一次在linux环境下安装jdk，这里记录一下安装和配置的过程供以后参考。</p>
<p><strong>1.下载</strong></p>
<p>首先在Oracle官网上下载jdk，这里给一个链接：
<a class="reference external" href="http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html">jdk7-downloads</a></p>
<p>选择合适的jdk版本下载，这里我下载的是jdk-7u17-linux-i566.tar.gz。</p>
<p><strong>2.安装</strong></p>
<p>在任意文件夹下解压这个压缩包，例如在/usr/java下：</p>
<div class="highlight"><pre><span class="go">sudo mkdir /usr/java</span>
<span class="go">sudo cp ~/Downloads/jdk-7u17-linux-i586.tar.gz /usr/java/</span>
<span class="go">cd /usr/java</span>
<span class="go">sudo tar -xvf jdk-7u17-linux-i585.tar.gz</span>
</pre></div>
<p>这样jdk就安装在/usr/java/jdk1.7.0_17目录下。</p>
<p><strong>3.修改环境变量</strong></p>
<p>修改~/.bashrc文件：</p>
<div class="highlight"><pre><span class="go">vim ~/.bashrc ...</span></pre></div> <a class="btn primary xsmall" href="http://hyhx2008.github.com/ubuntuxia-javade-an-zhuang-yu-pei-zhi.html">more…</a>
	</div>
</div>	
<div class='article'>
	<h2>PeerSim使用教程(5)-Event-drive(事件驱动)模型</h2>
	<div class="well small">Permalink: <a class="more" href="http://hyhx2008.github.com/peersimshi-yong-jiao-cheng-5-event-driveshi-jian-qu-dong-mo-xing.html">2013-04-12 17:46:00</a>
by <a class="url fn" href="http://hyhx2008.github.com/author/hyhx2008.html">hyhx2008</a>in <a href="http://hyhx2008.github.com/category/peersim.html">peersim</a>
tags: <a href="http://hyhx2008.github.com/tag/PeerSim.html">PeerSim</a> </div>
	<div class="summary"><p><strong>1.简介</strong></p>
<p>本教程使用Event-driven模型来演示一个简单的例子，仍然使用的是gossip-based平均数协议，对消息的发送将进行更细节的建模；通过与cycle-based模型的对比，可以发现本协议存在的问题。</p>
<p>在Event-based模型中，除了时间管理和control传递给protocols的方式以外，其它与cycle-based模型相同。
不可执行的Protocols(只用于存储数据，比如只存储邻居节点的linkable协议，或存储数值的vectors)可以以同样的方式应用和初始化，在peersim.cdsim包之外的controls也都可以使用。
在默认情况下，在cycle-based模型中，controls会的每个周期中调用 ，但在event-based模型中，它们需要进行明确的调度，因为事件驱动模型并不存在周期的概念。</p>
<p>显然，我们可以编写专用于Event-based模型的controls，即可以给协议发送事件(消息)。在很多情况下，这是必要的，因为系统经常完全或部分地由外部事件如用户的查询来驱动，这能很好地用由生成这些事件，并且驱动仿真执行的controls进行建模。</p>
<p>有些组件是不可用的。例如依赖于静态类peersim.cdsim.CDState(它提供了读取cycle相关的全局状态的接口)的所有组件。
我们的经验是，很多依赖于这个状态的cycle-based 组件可以经过简单的修改并删除这个依赖。</p>
<p>然而，可能有些令人吃惊的是，实现了cycle-based接口的peersim.cdsim.CDProtocol也可以使用于event-based模型，但是必须指出，在大部份的情况下这样做没有什么意义。
然而，这个特性的有用之处在于 ...</p> <a class="btn primary xsmall" href="http://hyhx2008.github.com/peersimshi-yong-jiao-cheng-5-event-driveshi-jian-qu-dong-mo-xing.html">more…</a>
	</div>
</div>	
<div class='article'>
	<h2>PeerSim使用教程(4)-构建一个拓扑生成器</h2>
	<div class="well small">Permalink: <a class="more" href="http://hyhx2008.github.com/peersimshi-yong-jiao-cheng-4-gou-jian-ge-tuo-bu-sheng-cheng-qi.html">2013-04-04 21:45:00</a>
by <a class="url fn" href="http://hyhx2008.github.com/author/hyhx2008.html">hyhx2008</a>in <a href="http://hyhx2008.github.com/category/peersim.html">peersim</a>
tags: <a href="http://hyhx2008.github.com/tag/PeerSim.html">PeerSim</a> </div>
	<div class="summary"><p>本文描述了在PeerSim中如何构建一个新的拓扑生成器。</p>
<p><strong>1.什么是拓扑？为什么它很重要？</strong></p>
<p>在一个大型的动态P2P系统中，节点没有关于整个网络的信息，而所有的节点都可能拥有一些邻居节点，即节点能”感知”的peers，这种”感知”的关系就定义了一个覆盖网络，这是P2P系统中的一个基本概念。</p>
<p>很多P2P协议都需要在多个不同的网络拓扑上进行实验。PeerSim中的peersim.dynamic.Wire*类已经包含了很多拓扑结构，可以直接用来对linkable协议进行初始化，本教程将展示如何构建一个自定义的拓扑生成器。</p>
<p><strong>2.一个模拟Internet的简单模型</strong></p>
<p>下面我们将编写一个拓扑生成器来构建类似于Internet的树状拓扑，整个构建过程基于一个特定的，与位置相关的preferential attachment方法，编写规则很简单，并且会考虑几何和网络的限制以更好地模拟真实的网络。
Preferential attachment由参数a来调整，这个参数能扩大或减少几何位置所带来的影响。</p>
<p>这个规则的策略如下：给定一个单位正方形，将x0置于中心，即x0 = (0.5,0.5)，这个节点被称为root，令W()为与root相隔的跳数(hops)，对于i=1 … n-1，随机在单位正方形中选择一个xi，然后选择使下面的表达式值最小的节点xj来连接它：</p>
<div class="figure">
<img alt="../statics/pics/peersim_tutorial_4_figure_1.png" src="../statics/pics/peersim_tutorial_4_figure_1.png" />
</div>
<p>在这里dist ...</p> <a class="btn primary xsmall" href="http://hyhx2008.github.com/peersimshi-yong-jiao-cheng-4-gou-jian-ge-tuo-bu-sheng-cheng-qi.html">more…</a>
	</div>
</div>	
<div class='article'>
	<h2>PeerSim使用教程(3)-编写一个新协议</h2>
	<div class="well small">Permalink: <a class="more" href="http://hyhx2008.github.com/peersimshi-yong-jiao-cheng-3-bian-xie-ge-xin-xie-yi.html">2013-03-24 19:35:00</a>
by <a class="url fn" href="http://hyhx2008.github.com/author/hyhx2008.html">hyhx2008</a>in <a href="http://hyhx2008.github.com/category/peersim.html">peersim</a>
tags: <a href="http://hyhx2008.github.com/tag/PeerSim.html">PeerSim</a> </div>
	<div class="summary"><p><strong>1.编写一个新协议</strong></p>
<p>我们将要实现的协议是在PeerSim中基于Cycle-based模型的一个简单的负载均衡算法。节点的状态有两种值：本地负载(local load)和配额(quota)，其中配额是指节点在每个周期中允许传输的“负载”的大小。配额是必要的，是一个时间单元中能传输的负载上限。每个节点与和它距离最远的邻居节点交换配额值，这里“距离最远”是指与当前节点的负载差异最大。经过对比距离，协议将在负载均衡时选用push或pull的方式。</p>
<p>在每个周期之后，配额值将会被存储。协议并不关心拓扑管理，它依赖于其它组件来访问邻居节点(例如，Newscast，或者由IdleProtocol实现的静态拓扑)。</p>
<p><strong>1.1 必要的组件</strong></p>
<p>一般来说只编写一个协议类是不足够的，还需要一些附加的组件。例如，为了在每个周期结束时为每个节点存储配额值，需要一个特定的Control对象。基本上来说，PeerSim是一个可替换的组件集合，所以在开发时需要注意模块化以让代码尽可能重用，出于这样的目的，我们这样设计下面的类：</p>
<p><em>protocol</em></p>
<blockquote>
它基于peersim.vector.SimpleValueHolder，这是一个简单的基类，用于访问一个浮点变量。Aggreation协议也使用了同样的基类。</blockquote>
<p><em>ResetQuota</em></p>
<blockquote>
用于在每个周期结束时存储每个节点配额的Control。</blockquote>
<p><em>QuotaObserver ...</em></p> <a class="btn primary xsmall" href="http://hyhx2008.github.com/peersimshi-yong-jiao-cheng-3-bian-xie-ge-xin-xie-yi.html">more…</a>
	</div>
</div>	
<div class='article'>
	<h2>PeerSim使用教程(2)-解析Cycle-based模式仿真</h2>
	<div class="well small">Permalink: <a class="more" href="http://hyhx2008.github.com/peersimshi-yong-jiao-cheng-2-jie-xi-cycle-basedmo-shi-fang-zhen.html">2013-03-21 20:10:00</a>
by <a class="url fn" href="http://hyhx2008.github.com/author/hyhx2008.html">hyhx2008</a>in <a href="http://hyhx2008.github.com/category/peersim.html">peersim</a>
tags: <a href="http://hyhx2008.github.com/tag/PeerSim.html">PeerSim</a> <a href="http://hyhx2008.github.com/tag/Cycle-based.html">Cycle-based</a> </div>
	<div class="summary"><p>PeerSim提供的文档并不多，一共三篇，可以在其官网上下载，这里给一个链接:
<a class="reference external" href="http://peersim.sourceforge.net/#docs">PeerSim: Documentation</a>
，是学习PeerSim必看资料。</p>
<p>英文有时不是很好理解，网上有个哥们将其翻译成中文了，不过他的网页最近好像失效了，这里和后面的教程基本上是整理了一下他的翻译，同时也感谢那位哥们的工作。</p>
<p>本文介绍了PeerSim的基本概念，并解析了两个示例以更清晰地说明PeeSim的仿真流程。</p>
<p>Peersim支持两种仿真模式，即Cycle-based模型和传统的Event-based模型，本文专注于前者的讲解。</p>
<p>Cycle-based模型是一个简化的模型，拥有更好的伸缩性及性能，在拥有4GB内存的情况下，Event-driven模式目前最多支持十万节点级别，而Cycle-based模式则支持千万个节点级别。 但是Cycle-based模型缺少对传输层的仿真和并行处理，节点之间是直接通信的，仿真核心以一定的顺序周期性地给以节点控制。在运行时，可以进行任意的操作，如调用其它对象的方法并执行一些计算。</p>
<p>Cycle-based模型损失了一些真实性，虽然一些简单的协议可以忽略这些差别，但是在选择使用这个模型时，需要注意这些区别。我们可以相对简单地将Cycle-based的仿真移植到Event-driven引擎上，但在本文中不讨论这个话题。</p>
<p><strong>1.PeerSim仿真的生命周期</strong></p>
<p>PeerSim鼓励基于接口的模块化编程，每一个组件都能被其它实现了相同接口的组件代替，一般的仿真过程如下：</p>
<blockquote>
<p>1&gt; 选择网络大小(即节点数量)。</p>
<p>2&gt; 选择要实验的一个或多协议并进行初始化。</p>
<p>3&gt; 选择一个或多个Control对象来监视感兴趣的属性，并在仿真时修改一些参数(比如，网络大小，协议的内部状态 ...</p></blockquote> <a class="btn primary xsmall" href="http://hyhx2008.github.com/peersimshi-yong-jiao-cheng-2-jie-xi-cycle-basedmo-shi-fang-zhen.html">more…</a>
	</div>
</div>	

<div class="pagination">
<ul>
			<li class="prev disabled"><a href="#">&larr; Previous</a></li>
				<li class="active"><a href="http://hyhx2008.github.com/index.html">1</a></li>
			<li class=""><a href="http://hyhx2008.github.com/index2.html">2</a></li>
				<li class="next"><a href="http://hyhx2008.github.com/index2.html">Next &rarr;</a></li>
	</ul>
</div>

		<footer>
		  <p> Powered by <a href="http://alexis.notmyidea.org/pelican/">Pelican</a>, theme based on <a href="http://twitter.github.com/bootstrap/">Bootstrap, from Twitter</a>.</p>
		  <p>&copy; hyhx2008 2011</p>
		</footer>
	  </div>
   
	</div>
</body>
</html>